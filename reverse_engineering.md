<h1 align="center">Reverse Engineering</h1>

-   ## OPERATING SYSTEM

-   ## Reverse Engineering concepts

-   ## The Immunity debugger

-   ## GDB Debugger

-   ## Malware analysis

\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-

<h1 align="center">OPERATING SYSTEM</h1>

-   # LOGICAL ADRESSES VS PHYSISCAL ADDRESSES :

    -   **Logical Address** **:** is generated by CPU while a program is running. The logical address is virtual address as it does not exist physically, therefore, it is also known as Virtual Address. This address is used as a reference to access the physical memory location by CPU The user can't view the physical address directly because of the memory protection..  The hardware device called Memory-Management Unit (MMU) is used for mapping logical address to its corresponding physical address.

    -   **Physical Address** **:** identifies a physical location of required data in a memory. The user never directly deals with the physical address but can access by its corresponding logical address. The user program generates the logical address and thinks that the program is running in this logical address but the program needs physical memory for its execution, therefore, the logical address must be mapped to the physical address by MMU before they are used. 

-   # SWAPPING:

    -   Swapping is a mechanism in which a process can be swapped temporarily out of main memory (or move) to secondary storage (disk) and make that memory available to other processes. At some later time, the system swaps back the process from the secondary storage to main memory. maybe that process finished its work or anything else

-   # context switching :

    -   A context switch is a procedure that a computer\'s CPU  follows to change from one task (or process) to another while ensuring that the tasks do not conflict it involves storing the context or state of a process so that it can be reloaded when required and execution can be resumed from the same point as earlier. This is a feature of a multitasking operating system and allows a single CPU to be shared by multiple processes.

    -   **context switching happens because of 3 things :**

        -   User and Kernel Mode Switching :change from kernal mode to user mode or the opposite

        -   Interrupt Handling: when an event occurs

        -   multitasking : for running multi process at the same time

-   # Interrupts vs polling

    -   TO RECIEVE DATA FROM hardware DEVICES WE HAVE 2 METHODS : {POLLING/INTERRUPTS}

    -   ## Polling

        -   os asks periodically every of these devices if they have any new information but its  time latency or interrupt

    -   ## Interrupts: 

        -   An interrupt is a signal from a device attached to a computer or from a program within the computer that requires the [operating system] to stop and figure out what to do next is an input signal to the processor.  An os has some code that is called an *interrupt handler*. (or an interrupt service routine, ISR) that prioritizes the interrupts and saves them in a [queue] if more than one is waiting to be handled. The os has another program, sometimes called a [scheduler][queue] that figures out which program to give control to next.

        -   **Hardware Interrupts**: are generated by hardware devices {such as keyboard, mouse , network adapter ,,,,} to signal that they need some attention from the OS because they have new data. They may have just received some data  e.g., keystrokes on the keyboard or an data on the ethernet card); or  they have just completed a task which the operating system previous requested, such as transfering data between the hard drive and memory.

        -   **Software Interupts  (TRAP):**.  A software interrupt (aka Programmed Exceptions) occur at the request of the programmer.or generated by programs They are used to implement system calls. Software interrupt is a considered to be an exception (because they are synchronous). Note that as far as Linux is concerned, software interrupt are handled by the CPU as trap so you might see somewhere else that system calls are implemented by trap.

-   # Dynamic libraries vs Static libraries

    -   ## dynamic vs static loading:

        -   At the time of loading, with **static loading**, the absolute program (and data) is loaded into memory in order for execution to start.

        -   If you are using **dynamic loading**, dynamic routines of the library are stored on a disk in relocatable form and are loaded into memory only when they are needed by the program.

    -   ## Linking Files

        -   **static linking**

            -   functions and variables which are defined in external library files are linked inside your executable by the linker. That means that the code is actually linked against your code when compiling/linking.  Examples of static libraries (libraries which are statically linked) are, ***.a*** files in Linux and ***.lib ***files in Windows.

        -   **dynamic linking**

            -   external functions that you use in your software are not linked against your executable. Instead they reside in a external library files which are only referenced by your software. Ie: the compiler/linker instructs the software on where to find the used functions. and loaded into memory in runtime only  ex of Dynamic libraries (libraries which are linked at run-time) are, ***.so*** in Linux and ***.dll*** in Windows.

    -   ## Types of libraries:

        -   On virtually all operating systems, there are 2 types of libraries. Static libraries and dynamic libraries. In windows the file extensions are as follows: Static libraries (.lib) and dynamic libraries (.dll). The main difference is that static libraries are linked to the executable at compile time; whereas dynamic linked libraries are not linked until run-time.

        -   You don\'t normally see static libraries though on your computer, because a static library is embedded directly inside of a module (EXE or DLL). A dynamic library is a stand-alone file.

    -   ## What is a DLL?

        -   Dynamic Link Libraries (DLL)s are like EXEs but they are not directly executable. They are similar to .so files in Linux/Unix. That is to say, DLLs are MS\'s implementation of shared libraries.

        -   DLLs are so much like an EXE that the file format itself is the same. Both EXE and DLLs are based on the Portable Executable (PE) file format. DLLs can also contain COM components and .NET libraries.

        -   What does a DLL contain?

            -   A DLL contains functions, classes, variables, UIs and resources (such as icons, images, files,) that an EXE, or other DLL uses.

![cpu](images/operating_system/cpu.jpeg)

-   # processing :

    -   ## Terminologies :

        -   **process:** is a program in execution or running, a program can have multiple process , programs can't become a process until they are loaded in memory

        -   **thread** : a process can be divides into multiple threads (lightweight process) threads can work in parallel

        -   **kernel** : the kernel is always loaded in memory

        -   **dispatcher** : trace the processes running

        -   **Multiprogramming** :Sharing the processor, when two or more programs reside in memory at the same time, is referred as multiprogramming

    -   ## process control block (pcb)  : os stores info about the process in the PCB

        -   **Process State:** Thecurrent state of the process i.e., whether it is ready, running, waiting, or whatever.

        -   **Process privileges: ** This is required to allow/disallow access to system resources.

        -   **Process ID:**  Unique identification for each of the process in the operating system.

        -   **Pointer:** A pointer to parent process.

        -   **Program Counter:** Program Counter is a pointer to the address of the next instruction to be executed for this process.

        -   **CPU registers:** Various CPU registers where process need to be stored for execution for running state.

        -   **CPU Scheduling Information:** Process priority and other scheduling information which is required to schedule the process.

        -   **Memory management information :** This includes the information of page table, memory limits, Segment table depending on memory used by the operating system

        -   **Accounting information: This** includes the amount of CPU used for process execution, time limits, execution ID etc.

        -   **IO status information :** This includes a list of I/O devices allocated to the process

    -   ## The process scheduling

        -   is the activity of the process manager that handles the removal of the running process from the CPU and the selection of another process on the basis of a  particular strategy.

        -   Process scheduling is an essential part of a Multiprogramming operating systems. Such operating systems allow more than one process to be loaded into the executable memory at a time and the loaded process shares the CPU using time multiplexing

        -   A Process Scheduler schedules different processes to be assigned to the CPU based on particular scheduling algorithms. There are six popular process scheduling algorithms :

            -   First-Come, First-Served (FCFS) Scheduling

            -   Shortest-Job-Next (SJN) Scheduling

            -   Priority Scheduling

            -   Shortest Remaining Time

            -   Round Robin(RR) Scheduling

            -   Multiple-Level Queues Scheduling

        -   These algorithms are either **non-preemptive or preemptive**. Non-preemptive algorithms are designed so that once a process enters the running state, it cannot be preempted until it    completes its allotted time, whereas the preemptive scheduling is based on priority where a scheduler may preempt a low priority running process anytime when a high priority process enters into a ready state.

    -   ## cpu modes : protected mode /real mode/system management mode

        -   **REAL MODE**:  Real mode is used by DOS and Standard DOS applications.  In x86 Intel processors, before the introduction of 80286, *everything* was real mode. It is **real** because all the programs run on the bare metal: *no* memory paging, *no* memory protection, *no* multitasking; nothing but the bare cpu metal running underneath. In this mode the cpu can use 20 bit segmented addresses, meaning it can access up to 1MB of *flat* memory.

        -   **PROTECTED MODE**: (used by most all modern os) In the 80286, **protected mode** was introduced (It was greatly enhanced in the 30386 chip). Here, the processor allows an OS to do multitasking, use virtual memory paging, and does memory access protection. Memory is accessed by use of 32 bit virtual addresses. And can access up to 4 gb

-   # MEMORY ALLOCATION

    -   ## Contiguous memory allocation

        -   is one of the oldest memory allocation schemes  all the available memory space remain together in one place  can be implemented in operating systems with the help of two registers, known as the base and limit registers. When a process is executing in main memory, its base register contains the starting address of the memory location where the process is executing, while the amount of bytes consumed by the process is stored in the limit register.  Physical Address = Base register address + Logical address/Virtual address

        -   main memory composed of 2 parts

            -   kernel space (os processes)

            -   user space (user processes)

        -   we have 2 options :

            -   single partition : all user processes share the same memory space

            -   multiple partition : each process has his own partition 

                -   fixed-sized partitions : by dividing the memory into the fixed-sized** partition** and allocate each partition to a single process only

                -   variable-sized partition by dividing the memory into the variable-sized** partition**

        -   **variable sized-partition**:    

            -   Hole: is a block of available memory  when the processes arrive in the memory, executes, terminates and leaves the memory you will see the set of holes of variable sizes.

            -   **PARTITON ALLOCATION:**

                -   **First Fit** : In the first fit, the partition is allocated which is first sufficient block(hole) from the top of Main Memory.

                -   **Best Fit ** : Allocate the process to the partition which is the first smallest sufficient partition(hole) among the free available partition.

                -   **Worst Fit ** : Allocate the process to the partition which is the largest sufficient (hole)among the freely available partitions available in the main memory.

        -   **FRAGMENTATION:** lama process temshi w tesib makanha hole w tigi process badalha fi nafs el hole

            -   **External fragmentation** : is when Total memory space is enough to satisfy a process but its not contiguous el holes soghayara w mesh gamb ba3d fa ben3mel compaction lel partitions dih 3ashan yefdal hole kebira 2a2dar 2a7ot fiha el process

            -   **internal fragmentation** : occurs when the process does not fully utilize the memory allocated to it.or the whole hole   Memory block assigned to process is bigger. Some portion of memory is left unused

    -   ## Non-contiguous memory allocation

        -   divides the process into several blocks and place them at the different location in the memory 

        -   the process is divided into blocks (pages or segments) which are placed into the different area of memory space according to the availability of the memory.

        -   it has an advantage of reducing memory wastage but, but it increases the overheads of address translation                   

        -   the os needs to maintain the **table** for each **process** which contains the base address of the each block that belongs by the process in memory space.

            -   Paging

            -   Segmentation

            -   Segmentation with paging

    -   ### PAGGING:

        -   divides the logical address space in to pages that are small equal in size blocks and divides the physical address space in to small equal in size blocks called frames the nb of frames =nb of 

        -   pages   to avoid external fragmentation

        -   page table is the one that transform the logical address into physical address

        -   Page address is called **logical address** and represented by **page number** and the **offset**.

            -   Logical Address = Page number + page offset

        -   Frame address is called **physical address** and represented by a **frame number** and the **offset**.

            -   Physical Address = Frame number + page offset

        -   The actual size of a page of memory differs between processor architectures, and some architectures support more than one page size. IA-32 processors generally use 4K pages, though they also support 2 MB and 4 MB pages. For the most part Windows uses 4K pages, so you can generally consider that to be the default page size.

        -   Paging enables the creation of multiple address spaces. An address space is an isolated page table that only allows access to memory that is pertinent to the current program or process. Because the process prevents the application from accessing the page table, it is impossible for the process to break this boundary. The concept of multiple address spaces is a fundamental feature in modern operating systems, because it ensures that programs are completely isolated from one another and that each process has its own little "sandbox" to run in.

    -   ### SEGMENTATION

        -   Segmentation memory management works very similar to paging but here dividing a process into segments that are of variable-length where as in paging pages are of fixed size.

-   # Memory Management concepts

    -   ## Virtual address space

        -   Since Windows and Linux are capable of multitasking, every process has its own Virtual Address Space (VAS). For a 32-bit operating system, the VAS has a size of 4 GB. Each VAS is mapped to the physical memory using its respective page table and is managed by the operating system\'s kernel. So how do multiple VASes fit in the physical memory? The operating system manages this using paging. The paging has a list of used and unused memory, including privilege flags. If the physical memory is not enough, then paging can use disk space as an form of extended physical memory. A process and its module dependencies don\'t use up the whole 4 GB of space, and only these virtually allocated memory segments are listed as used in the page tables and mapped in the physical memory. A VAS is divided into two regions: user space and kernel space, with the kernel space located in the higher address region. The division of virtual space differs between Windows and Linux:

    -   ## Direct Memory Access (DMA)

        -   Slow devices like keyboards will generate an interrupt to the main CPU after each byte is transferred. If a fast device such as a disk generated an interrupt for each byte, the operating system would spend most of its time handling these interrupts. So a typical computer uses direct memory access (DMA) hardware to reduce this overhead.

        -   Direct Memory Access (DMA) means CPU grants I/O module authority to read from or write to memory without involvement. DMA module itself controls exchange of data between main memory and the I/O device. CPU is only involved at the beginning and end of the transfer and interrupted only after entire block has been transferred.

    -   ## virtual memory

        -   it is a section of a hard disk that\'s set up to emulate and increase the computer\'s RAM.  Virtual memory is commonly implemented by demand paging. It can also    be   implemented in a segmentation system. Demand segmentation can also be used to provide virtual memory.

    -   ## A demand paging

        -   System is quite similar to a paging system with swapping where processes reside in secondary memory and pages are loaded only on demand, not in advance.

        -   While executing a program, if the program references a page which is not available in the main memory because it was swapped out a little ago, the processor treats    this invalid memory reference as a **page fault** and transfers control from the program to the operating system to demand the page back into the memory.

    -   ## Page replacement algorithms

        -   are the techniques using which an Operating System decides which memory pages to swap out, write to disk when a page of memory needs to be allocated Paging happens whenever a page fault occurs

    -   ## Memory models 
        
        -   ![memory models](images/operating_system/memory_models.png)

        -   **Flat model** (we are using this model):  refers to a [memory addressing] paradigm in which \"[memory] appears to the program as a single contiguous [address space] . The [CPU] can directly [address][memory addressing] all of the available [memory] locations Without having to resort to any sort of [memory segmentation] or [paging] schemes.

        -   **segmented model** : done by segmentation memory allocation

        -   **Paged memory model**:  done by paging memory allocation

        -   **Real address mode model**: uses segment registers. An addresses is the value specified by the programmer plus the value in a segment register, In some cases, the segment may be implicit from the particular instruction.

-   # Memory protection

    -   Memory protection is a way to control memory access rights on a computer,  to prevent a process from accessing memory that has not been allocated to it. This prevents a bug or malware within a process from affecting other processes, or the operating system itself

        -   methods : segmentation , paged virtual memory

-   # VAD Trees

    -   A Virtual Address Descriptor (VAD) tree is the data structure used by Windows for managing each individual process's address allocation. The VAD tree is a binary tree that describes every address range that is currently in use. Each process has its own individual tree, and within those trees each entry describes the memory allocation in question. Generally speaking, there are two distinct kinds of allocations: mapped allocations and private allocations. Mapped allo- cations are memory-mapped files that are mapped into the address space. This includes all executables loaded into the process address space and every memory-mapped file (section object) mapped into the address space. Private allocations are allocations that are process private and were allocated locally. Private allocations are typically used for heaps and stacks (there can be multi- ple stacks in a single process---one for each thread).

-   # What happens when a program starts

    -   When an application is stared in a Win32 environment, a process is created and virtual memory is assigned to.  In a 32 bit process, the address ranges from 0x00000000 to 0xFFFFFFFF, where 0x00000000 to 0x7FFFFFFF is assigned to \"user-land\", and 0x80000000 to 0xFFFFFFFF is assigned to \"kernel land\".  Windows uses the flat memory model, which means that the CPU can directly/sequentially/linearly address all of the available memory locations, without having to use a segmentation/paging scheme.

    -   When a process is created, a PEB (Process Execution Block) and TEB (Thread Environment Block) are created.

    -   The PEB contains all user land parameters that are associated with the current process :

        -   location of the main executable

        -   pointer to loader data (can be used to list all dll's / modules that are/can be loaded into the process)

        -   pointer to information about the heap

    -   The TEB describes the state of a thread, and includes

        -   location of the PEB in memory

        -   location of the stack for the thread it belongs to

        -   pointer to the first entry in the SEH chain

        -   Each thread inside the process has one TEB.

-   # Program life cycle

    ![compilation process](images/operating_system/decompile.png)  ![cpu](images/operating_system/compilation_path.png)


    -   ## Preprocessor

        -   The source code is the code which is written in a text editor and the source code file is given an extension \".c\". This source code is first passed to the preprocessor, and then the preprocessor expands this code. After expanding the code, the expanded code is passed to the compiler

    -   ## Compiler

        -   The code which is expanded by the preprocessor is passed to the compiler. The compiler converts this code into assembly code. Or we can say that the C compiler converts the pre-processed code into assembly code

    -   ## Assembler

        -   The assembly code is converted into object code by using an assembler. The name of the object file generated by the assembler is the same as the source file. The extension of the object file in DOS is \'.obj,\' and in UNIX, the extension is \'o\'. If the name of the source file is \'hello.c\', then the name of the object file would be \'hello.obj\'

    -   ## Linker

        -   Mainly, all the programs written in C use library functions. These library functions are pre-compiled, and the object code of these library files is stored with \'.lib\' (or \'.a\') extension. The main working of the linker is to combine the object code of library files with the object code of our program. Sometimes the situation arises when our program refers to the functions defined in other files; then linker plays a very important role in this. It links the object code of these files to our program. Therefore, we conclude that the job of the linker is to link the object code of our program with the object code of the library files and other files. The output of the linker is the executable file. The name of the executable file is the same as the source file but differs only in their extensions. In DOS, the extension of the executable file is \'.exe\', and in UNIX, the executable file can be named as \'a.out\'. For example, if we are using printf() function in a program, then the linker adds its associated code in an output file.

<h2 align="center">REVERSE ENGINEERING</h2>

-   # RAM:

    ![memory](images/operating_system/memory-layout.png)

    -   ## STACK: 

        -   A stack is an area in program memory that is used for short-term storage of information by the CPU and the program. It can be thought of as a secondary storage area for short-term information. Registers are used for storing the most immediate data, and the stack is used for storing slightly longer-term data. Physically, the stack is just an area in RAM that has been allocated for this purpose. Stacks reside in RAM just like any other data---the distinction is entirely logical. It should be noted that modern operating systems manage multiple stacks at any given moment---each stack represents a currently active program or thread. Internally, stacks are managed as simple LIFO (last in, first out) data structures, where items are "pushed" and "popped" onto them. Memory for stacks is typically allocated from the top down, meaning that the highest addresses are allocated and used first and that the stack grows "backward," toward the lower addresses stack are used to store :

            -   local variables

            -   function parameters and return addresses

            -   Temporarily saved register values : save the value of a register into another register

        -   push and pop 4bytes at a time

        -   start at the highest address toward the lowest address

        -   The stack instructions include push, pop, call, leave, enter, and ret.

        -   The x86 architecture provides additional instructions for popping and pushing, the most popular of which are pusha and pushad. These instructions push all the registers onto the stack and are commonly used with popa and popad, which pop all the registers off the stack. The pusha and pushad functions operate as follows:

            -   pusha pushes the 16-bit registers on the stack in the following order: AX, CX, DX, BX, SP, BP, SI, DI.

            -   pushad pushes the 32-bit registers on the stack in the following order: EAX, ECX, EDX, EBX, ESP, EBP, ESI, EDI.

    -   ## EXECUTABLE DATA: 

        -   this area typically contains either global variables or preinitialized data. Preinitialized data is any kind of constant, hard-coded information included with the program.

    -   ## HEAP:

        -   Heaps are typically used for variable-sized objects that are used by the program or for objects that are too big to be placed on the stack

    -   ## Code: 

        -   stores the instructions of the program

-   # Execution Environments

    -   An execution environment is the component that actually runs programs. This can be a CPU or a software environment such as a virtual machine. the two basic types of execution environments, which are virtual machines and microprocessors

        -   Software Execution Environments (Virtual Machines) : Two common virtual machine architectures are the Java Virtual Machine (JVM) that runs Java programs, and the Common Language Runtime (CLR) that runs Microsoft .NET applications

        -   Hardware Execution Environments in Modern Processors

-   # Virtual Machines and Bytecodes :

    -   Compilers for high-level languages such as Java generate a bytecode instead of an object code. Bytecodes are similar to object codes, except that they are usually decoded by a program, instead of a CPU. The idea is to have a compiler generate the bytecode, and to then use a program called a virtual machine to decode the bytecode and perform the operations described in it. Of course, the virtual machine itself must at some point convert the bytecode into standard object code that is compatible with the underlying CPU. There are several major benefits to using bytecode-based languages. One significant advantage is platform independence. The virtual machine can be ported to different platforms, which enables running the same binary program on any CPU as long as it has a compatible virtual machine

-   # HIGH LEVEL LANGUAGES :

    -   Some languages such as C provide a fairly low-level perspective on the machine and produce code that directly runs on the target processor. Other languages such as Java provide a substantial level of separation between the programmer and the underlying processor.

    -   a compiled language, meaning that to run the program you must run the source code through a compiler that generates platform-specific program binaries. These binaries contain machine code in the target processor's own native language

    -   C++ takes C to the next level in terms of flexibility and sophistication by introducing support for object-oriented programming ( C++ is the equivalent of C = C + 1. )

    -   Java is an object-oriented, high-level language that is different from other languages such as C and C++ because it is not compiled into any native processor's assembly language, but into the Java bytecode. Briefly, the Java instruction set and bytecode are like a Java assembly language of sorts, with the difference that this language is not usually interpreted directly by the hardware, but is instead interpreted by software (the Java Virtual Machine). Java's primary strength is the ability to allow a program's binary to run on any platform for which the Java Virtual Machine (JVM) is available.

    -   C\# programs are compiled into an intermediate bytecode format (similar to the Java bytecode) called the Microsoft Intermediate Language (MSIL). MSIL programs run on top of the common language runtime (CLR), which is essentially the .NET virtual machine. The CLR can be ported into any platform, which means that .NET programs are not bound to Windows---they could be executed on other platforms

    -   **There are two basic code-level constructs that are considered the most fundamental building blocks for a program**.

        -   procedures programing

        -   Object. oriented progamming

-   # Tools used in Reverse Engineering

    -   ## binary analysis tools

        -   Binary analysis tools are used to parse binary files and extract information about the file HxD and HIEW are popular binary editors

    -   ## Monitoring tools.

        -   Monitoring tools are used to monitor system behaviors regarding file, registry, memory, and network. These tools usually tap or hook on APIs or system calls, then log information such as newly created processes, updated files, new registry entries, and incoming SMB packets are generated by reporting tools.

        -   **Tools**

            -   **Monitor system changes**

                -   For Windows, there are three aspects we need to monitor: memory, disk, and registry. File monitoring tools look at created, modified, or deleted files and directories. On the other hand, registry monitoring tools look at created, updated, or deleted registry keys, values, and data.

            -   **Process Monitor**

                -   SysInternals Suite\'s Procmon or Process Monitor is an advanced monitoring tool for Windows that provides a way to monitor certain registry, file system, network, process, and thread activity. It combines and enhances the functionality of two legacy tools: FileMon and RegMon.

                -   Although procmon captures a lot of data, it doesn't capture everything. For example, it can miss the device driver activity of a user-mode component talking to a rootkit via device I/O controls, as well as certain GUI calls, such as SetWindowsHookEx. Although procmon can be a useful tool, it usually should not be used for logging network activity, because it does not work consis- tently across Microsoft Windows versions.

            -   **API Monitor**

                -   This powerful tool helps reverse engineering by monitoring API calls as the program runs. The analyst has to set which API the tool needs to hook. Once an API is hooked, all user-mode processes using the API will be logged. API Monitor can be downloaded from http:/​/​www.​rohitab.​com/ apimonitor.

            -   **Monitor Network traffic**

                -   The communicated data between a server and a client computer can only be seen during dynamic analysis. The packet captured during transmission will help the analyst understand what the program is sending to a server and how it will respond to any such data received. Popular tools, such as Wireshark and Fiddler, are used to capture packets of data and store them as pcap files. In Linux, the tcpdump tool is commonly used to do the same thing.

                -   **CaptureBAT**

                    -   In addition to what Process Monitor can do, this command-line tool is also capable of monitoring network traffic.

    -   ## Patching tools

        -   Patching is the process of modifying code in a binary executable to somehow alter its behavior. Patching is related to reversing because in order to know where to patch, one must understand the program being patched. Patching almost always comes after a reversing session in which the program is analyzed and the code position that needs to be modified is located. Patching is typically performed by crackers

    -   ## disassemblers

    -   ## decompilers

    -   ## Debuggers

-   # DEBUGGERS VS DEASSEMBLER VS DECOMPILER :

    -   ## DEBUGGERS: (dynamic analysis)

        -   A debugger is a program that allows software developers to observe their program while it is running. The two most basic features in a debugger are the ability to set breakpoints and the ability to trace through code. Breakpoints allow users to select a certain function or code line anywhere in the program and instruct the debugger to pause program execution once that line is reached.

        -   debuggers can be roughly divided into two very different flavors:

            -   Windows debuggers

                -   user-mode debugger :OllyDbg ,  WinDbg

                -    kernel-mode debuggers. Numega SoftICE ,

            -   Linux Debugger : GDB , radare2

    -   ## Disassemblers :  (static analysis)

        -   disassemblers are programs that take a program's executable binary as input and generate textual files that contain the assembly language code for the entire program or parts of it

    -   ## Decompilers:

        -   Decompilers are the next step up from disassemblers. A decompiler takes an executable binary file and attempts to produce readable high-level language code from it. or the source code

        -   Compiler Architecture The average compiler consists of three basic components. The front end is responsible for deciphering the original program text and for ensuring that its syntax is correct and in accordance with the language's specifications. The optimizer improves the program in one way or another, while preserving its original meaning. Finally, the back end is responsible for generating the platform-specific binary from the optimized code emitted by the optimizer

        -   compilers ex :  GCC and G++ version 3.3.1: The GNU C Compiler (GCC) and GNU C++ Compiler (G++) are popular open-source compilers  commonly used by developers working on Unix-based platforms such as Linux

        -   Microsoft C/C++ :The Microsoft Optimizing Compiler is one of the most common compilers for the Windows platform

-   # Different analysis in reverse: offline analysis and live analysis

    -   **Offline analysis (deadlisting)**: Offline analysis of code means that you take a binary executable and use a disassembler or a decompiler to convert it into a human-readable form. Reversing is then performed by manually reading and analyzing parts of that output. Offline  There are some cases (particularly cracking-related) where offline code analysis is not possible. This typically happens when programs are "packed," so that the code is encrypted or compressed and is only unpacked in runtime. In such cases only live code analysis is possible  Ex: IDA PRO ,ILDasm is a disassembler for the Microsoft Intermediate Language (MSIL),

    -   **live(dynamic)analysis** : Live Analysis involves the same conversion of code into a human-readable form, but here you don't just statically read the converted code but instead run it in a debugger and observe its behavior on a live system (when app is running)

        -   **Software and Hardware Breakpoints:**

            -   Breakpoints are a basic debugging feature, . Software breakpoints are instructions added into the program's code by the debugger at runtime. These instructions make the processor pause program execution and transfer control to the debugger when they are reached during execution. Hardware breakpoints are a special CPU feature that allow the processor to pause execution when a certain memory address is accessed, and transfer control to the debugger

-   # Application Programming Interfaces

    -   is a set of functions that the operating system makes available to application programs for communicating with the operating system based on modules dll files 

    -   The .NET Framework and many other  uses the System class for accessing operating system services, which is again an interface into the Win32 API.

    -   The Core Win32 API contains roughly 2000 APIs (it depends on the specific Windows version ). These APIs are divided into three categories: Kernel, USER, and GDI.

        -   **Kernel APIs** (also called the BASE APIs) are implemented in the KERNEL32.DLL module and include all non-GUI-related services, such as file I/O, memory management, object management, process and thread management, and so on. KERNEL32.DLL typically calls lowlevel native APIs from NTDLL.DLL to implement the various services.

        -   **GDI APIs** are implemented in the GDI32.DLL and include low-level graphics services such as those for drawing a line, displaying a bitmap, and so on.. The GDI revolves around GDI objects used for drawing graphics, such as device contexts, brushes, pens, and so on.

        -   **USER APIs** are implemented in the USER32.DLL module and include all higher-level GUI-related services such as window-management, menus, dialog boxes, user-interface controls, and so on. All GUI objects are drawn by USER using GDI calls to perform the actual drawing; USER heavily relies on GDI to do its business.

    -   Another important API

        -   **ADVAPI32** contains functions that has to do with the Windows registry.

        -   **MSVCRT** contains standard C library functions from Microsoft Visual C++ runtime, such as printf, scanf, malloc, strlen, fopen, and getch.

        -   **WS2\_32, WININET, URLMON, and NETAPI32** are libraries that contain functions that have to do with networking and internet communication.

    -   The Native API The native API is the actual interface to the Windows NT system. In Windows NT the Win32 API is just a layer above the native API

    -   A system call takes place when user-mode code needs to call a kernel-mode function

    -   More recent versions of the operating systems use an optimized version of the same mechanism. Instead of invoking an interrupt in order to perform the switch to kernel mode, the system now uses the special SYSENTER instruction in order to perform the switch.

-   # Endianness

    -   When reading or writing data to memory, we use the registers or memory to process them as BYTE, WORD, DWORD, or even QWORD. Depending on the platform or program, data is read in little-endian or big-endian form.

    -   In little-endian, a chunk of data read into a DWORD is reversed. Let\'s take the following piece of data as an example:

    -   AA BB CC DD

    -   When the data on a file or memory looks like this, in little-endian format, it will be read as DDCCBBAAh in a DWORD value. This endianness is common to Windows applications.

    -   In the big-endian system, the same chunk of data will be read as AABBCCDDh. The advantage of using the big-endian form arises when reading streaming data such as file, serial, and network streams.

    -   The advantage of reading in little-endian is that the address you read it from remains fixed, regardless of whether it is read as BYTE, WORD, or DWORD.


-   <h2 align="center">the Immunity Debugger :</h2>

    ![immunity](images/immunity.png)

    -   We can use an application called a debugger to assist with the exploit development process. A debugger acts as a proxy between the application and the CPU, and it allows us to stop the execution flow at any time to inspect the content of the registers as well as the process memory space. While running an application through a debugger, we can also execute assembly instructions one at a time to better understand the detailed flow of the code. Although there are many debuggers available, we will use Immunity Debugger,305 which has a relatively simple interface and allows us to use Python scripts to automate tasks

    -   ## The Immuniy debugger is composed of 4 parts :

        -   **The upper left window** shows the assembly instructions that make up the application. The instruction highlighted in blue (SUB ESP,0C) is the assembly instruction to be executed next and it's located at address 0x004014E0 in the process memory space:

        -   **The upper right window** contains all the registers, including the two we are most interested in: ESP and EIP. Since by definition EIP points to the next code instruction to be executed, it is set to 0x004014E0, the instruction highlighted in the assembly window

        -   **The lower right window** shows the stack and its content. This view contains four columns: a memory address, the hex data residing at that address, an ASCII representation of the data, and a dynamic commentary that provides additional information related to a particular stack entry when available. The data itself (second column) is displayed as a 32-bit value, called a DWORD, displayed as four hexadecimal bytes. Note that this pane shows the address 0x0065FF84 at the top of the stack and that this is, in fact, the value stored in ESP in the register window

        -   **The final window, in the lower left**, shows the contents of memory at any given address. Similar to the stack window, it shows three columns including the memory address and the hex and ASCII representations of the data

    -   ## Notes

        -   \<Since the entry point in this case does not coincide with the beginning of the main function, our first goal is to find where the main function is located in memory. \>

        -   \< we can place a breakpoint on any  instruction. A breakpoint is essentially an intentional pause that can be set by the debugger on any program instruction.  To set a breakpoint , we select the line in the disassembly window at address we want and press F2. Once set, the breakpoint will show the instruction line with a light blue highlight  \>

-   <h2 align="center">GDB Debugger</h2>

    -   ## GDB alias

        -   \$ cat \~/.bash\_aliases \| grep gdb

        -   alias gdb=\'gdb -quiet\'

    -   ## Running gdb

        -   \$ gdb - run, then use file command to load object

        -   \$ gdb -quiet - supress copyright information

        -   \$ gdb object - normal debug

        -   \$ gdb object core - analyze core dump

        -   \$ gdb object pid - attach to running process

    -   ## General commands

        -   Disassemble fun\_name - show all assembly instruction of that function

        -   set args - set program arguments

        -   show args - show program arguments

        -   run - run the program

        -   run \< file - run with input from file

        -   set follow-exec-mode new/sam - set debugger response to an exec call

        -   set write - set write into executables

        -   set write off - unset write int oexecutables

        -   continue - continue running until break

        -   finish - execute until current stack frame ends

        -   source FILE - read commands from script file

        -   shell \[cmd\] - run cmd in a shell

        -   display /5i \$eip - display expression everytime execution stops

        -   undisplay \<expr \#\> - undisplay expression number

        -   info functions - list all the functions

        -   info variables - list all the variables

        -   info registers - list most common registers

        -   info all-registers - list all registers include \[fpu ,xxm , mmx ,...\]

        -   info display - print the list of displayed expressions

        -   backtrace - print backtrace of all stack frames

        -   where - same as backtrace

        -   set disassembly-flavor intel - set disassembly style to intel/att

        -   define hook-\[cmd\] - actions to execute before command

        -   define hooopost-\[cmd\] - actions to execute after command

        -   define hook-stop - actions to execute when execution stops

    -   ## Breakpoints

        -   info breakpoints - list all breakpoints

        -   break \[func\] - break function name

        -   break \*\[addr\] - break at address

        -   delete \[bnum\] - delete breakpoint bnum

        -   break if \[cond\] - break if condition

        -   ignore \[bnum\] \[count\] - ignore breakpoint bnum count times

        -   condition \[bnum\] \$eax == 0x22 - add condition for breakpoint 1

        -   condition \[bnum\] - delete condition for breakpoint 1

    -   ## Watchpoints

        -   info watchpoints - list all the watchpoint

        -   watch variable==value - break when variable equals ..

        -   watch \$eax == 0x0000ffaa - break when register equals ..

        -   rwatch \*\[addr\] - break on read memory location

        -   awatch \*\[addr\] - break on read/write memory location


<h1 align="center">Malware analysis</h1>

-   # What is Malware analysis ?

    -   Malware analysis is the art of dissecting malware to understand how it works, how to identify it, and how to defeat or eliminate it

-   # Typical malware behavior

    -   ## Malware delivery

        -   In the software security industry, the activity of an attacker to spread and compromise a system is called a malware campaign. There are various ways that malware gets into a system. The most common way that these malware executable files are

            -   Emails

            -   Media Storage

            -   The computer network

            -   Instant messaging

        -   Malware Dropping

            -   The initial behavior of common malware is to drop a copy of itself, drop its malware component embedded in it, or download its malware component. It creates the dropped files which are usually found in these folders:

                -   The Windows System folder: C:\\Windows\\System32

                -   The Windows folder: C:\\Windows

                -   The user profile folder: C:\\Users\\\[username\]

                -   The Appdata folder: C:\\Users\\\[username\]\\AppData\\Roaming

                -   The recycle bin folder: C:\\\$Recycle.Bin

                -   The desktop folder: C:\\Users\\\[username\]\\Desktop

                -   The temporary folder: C:\\Users\\\[username\]\\AppData\\Local\\Temp

    -   ## Malware persistence

        -   **The Windows Registry**

            -   Auto run registry keys

            -   AppInit\_DLLs

                -   AppInit\_DLLs are loaded into every process that loads User32.dll, and a simple insertion into the registry will make AppInit\_DLLs persistent

            -   Winlogon.

                -   Malware authors can hook malware to a particular Winlogon event, such as logon, logoff, startup, shutdown, and lock screen. This can even allow the malware to load in safe mode.

            -   SvcHost DLLs

        -   **Trojanized System Binaries**

            -   With this technique, the malware patches bytes of a system binary to force the system to execute the malware the next time the infected binary is run or loaded. Malware authors typically target a system binary that

        -   **DLL Load-Order Hijacking**

    -   ## Malware payload

        -   Stealing accounts and passwords

        -   Stealing documents, images, and videos

        -   Changing specific configuration and settings

        -   Turning the computer into a proxy server

        -   Installing cryptocoin miners Continuously opening websites - ad or porn sites

        -   Installing more malware

        -   Installing adware

        -   Encrypting files for ransom

        -   Deleting all files

        -   Formatting drives

        -   Gaining full access to the system and the network

-   # Identify suspected files

    -   List down all processes and their respective file information

    -   From the list of known registry persistence paths, look for entries containing the file paths

    -   Extract the suspected files

    -   **Tools**

        -   pre-existing Windows tools such as

            -   the Registry editor

            -   Task Manager

            -   the Task Scheduler

        -   Tools from SysInternals

            -   autoruns

            -   Process explorer

-   # Hiding malware techniques

    -   **Crypters**: are software cryptographically alters executable code, adding a decrypting stub that restores the original code upon execution. This decryption happens in-memory, leaving only the encrypted code on-disk. Encryption has become foundational in modern malware as one of the most effective AV evasion techniques ( Hyperion) is a good tool for encrypting payloads

        -   Example :

            -   cp /usr/share/windows-binaries/Hyperion-1.0.zip

            -   unzip Hyperion-1.0.zip

            -   cd Hyperion-1.0/

            -   i686-w64-mingw32-g++ Src/Crypter/\*.cpp -o hyperion.exe

            -   cp -p /usr/lib/gcc/i686-w64-mingw32/5.3-win32/libgcc\_s\_sjlj-1.dll .

            -   cp -p /usr/lib/gcc/i686-w64-mingw32/5.3-win32/libstdc++-6.dll .

            -   wine hyperion.exe ../backdoor.exe ../crypted.exe

    -   **Obfuscators**: Obfuscators reorganize and mutate code in a way that makes it more difficult to reverse-engineer. against signature-based AV detection

    -   **Packers**: packers were originally designed to simply reduce the size of an executable. Unlike modern "zip" compression techniques, packers generate an executable that is not only smaller, but is also functionally equivalent with a completely new binary structure. The resultant file has a new signature and as a result, can effectively bypass older and more simplistic AV scanners

        -   Ex : upx -9 payload.exe

        -   When the packed program is run, a small wrapper program also runs to decompress the packed file and then run the unpacked file. When a packed program is analyzed statically, only the small wrapper program can be dissected.

        -   When a program is packed, you must unpack it in order to be able to perform any analysis.

        -   **Detecting Packers with PEiD**

            -   One way to detect packed files is with the PEiD program. You can use PEiD to detect the type of packer or compiler employed to build an application, which makes analyzing the packed file much easier.

    -   **Software protectors** : Highly effective antivirus evasion requires a combination of all of the previous techniques in addition to other advanced ones, including anti-reversing, anti-debugging

-   # Antivirus Scanning

    -   Using antivirus tools to confirm maliciousness (virustotal.com)

    -   Using hashes to identify malware: Hashing is a common method used to uniquely identify malware. The malicious software is run through a hashing program that produces a unique hash that identifies that malware (a sort of fingerprint). The Message-Digest Algorithm 5 (MD5) hash function is the one most commonly used for malware analysis, though the Secure Hash Algorithm 1 (SHA-1) is also popular

    -   Once you have a unique hash for a piece of malware, you can use it as follows:

        -   Use the hash as a label.

        -   Share that hash with other analysts to help them to identify malware.

        -   Search for that hash online to see if the file has already been identified.

-   # Finding strings in malware

    -   Gleaning information from a file's strings, functions, and headers :

    -   Strings searches an executable for ASCII and Unicode strings, it ignores context and formatting Strings searches for a three-letter or greater sequence of ASCII and Unicode characters, followed by a string termination character.

    -   Sometimes the strings detected by the Strings program are not actual strings. For example, if Strings finds the sequence of bytes 0x56, 0x50, 0x33, 0x00, it will interpret that as the string VP3. But those bytes may not actually represent that string; they could be a memory address, CPU instructions, or data used by the program. Strings leaves it up to the user to filter out the invalid strings.

    -   Legitimate programs almost always include many strings. Malware that is packed or obfuscated contains very few strings

-   # PE File Format ( Headers and Sections)

    -   ![PE structure](images/pe/pe1.png) ![PE structure](images/pe/pe1.png) 

    -   The PE file contains a header followed by a series of sections. The header contains metadata about the file itself. Following the header are the actual sections of the file, each of which contains useful information that tells the dynamic linker how to map the file into the memory

    -   The PE file header stores information about every library that will be loaded and every function that will be used by the program.

    -   EX of some PE extensions : DLL , EXE , .sys , .src , .acm ,....

    -   Exploring Dynamically Linked Functions with Dependency Walker The Dependency Walker program, lists only dynamically linked functions in an executable.

    -   One of the most useful pieces of information that we can gather about an executable is the list of functions that it imports. Imports are functions used by one program that are actually stored in a different program, such as code libraries that contain functionality common to many programs. Code libraries can be connected to the main executable by linking.

    -   Programmers link imports to their programs so that they don't need to re-implement certain functionality in multiple programs. Code libraries can be linked statically, at runtime, or dynamically. Knowing how the library code is linked is critical to our understanding of malware because the information we can find in the PE file header depends on how the library code has been linked.PE file headers can provide considerably more information than just imports..

    -   ## PE file Header

        -   Contains all the info required by the os to run the executable file

        -   **DOS Header**

            -   The dos header run the DOS stub in case the PE is running on BIOS

            -   starts with the first 64 bytes of every PE file

            -   **DOS MZ header**

                -   Contains the signature (magic byte) of the file this value is  set to 0x54AD, which represents the ASCII characters "MZ"

            -   **DOS stub**

                -   Used only for compatibility , its only function is to print a message "this program cannot be run in dos mode" when the application run on BIOS

        -   **The section table**

            -   contains all the information about where code and data are located in the file, and how it will be mapped into the memory when it gets loaded as a process. The PE header contains the address where the program begins to execute code---a location known as the entry point---and will be set in the EIP register.

        -   **The data directories**

            -   contain addresses of tables that, in turn, contain information such as the import table. The import table contains the libraries and APIs that will be used by the program. The table follows a structure that points to a set of addresses, pointing, in turn, to the names of libraries and their respective export functions:

    -   ## PE file sections :

        -   An application in Windows NT typically has nine different predefined sections, such as .text, .bss, .rdata, .data, .rsrc, .edata, .idata, .pdata, and .debug. Depending on the application, some of these sections are used, but not all are used.

        -   **.text**: The .text/.code section contains the instructions that the CPU exe- cutes. All other sections store data and supporting information. Generally, this is the only section that can execute, and it should be the only section that includes code. **(the entry point of the application is here)**

        -   **.rdata:** The .rdata section typically contains the import and export information, which is the same information available from both Dependency Walker and PEview. This section can also store other read-only data used by the program. Sometimes a file will contain an .idata and .edata section, which store the import and export information

        -   **.data:** The .data section contains the program's global data, which is accessible from anywhere in the program. Local data is not stored in this section, or anywhere else in the PE file.

        -   **.rsrc:** The .rsrc section includes the resources used by the executable that are not considered part of the executable, such as icons, images, menus, and strings. Strings can be stored either in the .rsrc section or in the main program, but they are often stored in the .rsrc section for multilanguage support

        -   **.idata** : (import data section) Sometimes present and stores the import function information; if this section is not present, the import function information is stored in the .rdata section

        -   **.edata :** (export data section) Sometimes present and stores the export function information such as the names and addresses of the export functions; if this section is not present, the export function information is stored in the .rdata section

        -   **.pdata** :Present only in 64-bit executables and stores exception-handling information

        -   **.bss** : holds uninitialized variables ex : int nb;

    -   ## Tools to view PE header :

        -   We can use the PEview tool , PEBrowse Professional or PE Explorer to view PE file header

    -   ## Resources

        -   <https://resources.infosecinstitute.com/2-malware-researchers-handbook-demystifying-pe-file/#article>

-   # Basic Dynamic analysis Tools

    -   1\. Running procmon and setting a filter on the malware executable name and clearing out all events just before running.

    -   2\. Starting Process Explorer.

    -   3\. Gathering a first snapshot of the registry using Regshot. Basic Dynamic Analysis 57

    -   4\. Setting up your virtual network to your liking using INetSim and ApateDNS.

    -   5\. Setting up network traffic logging using Wireshark.

-   # Initial malware analysis

    -   ## File information: (file name, size , ..)

    -   ## identifying file hash

        -   Information gathering also includes identifying a file by its hash. Not only does the hash help validate a transferred file; it is also commonly used as a unique ID for a file analysis profile:

        -   \-**Quickhash**: This is an open source tool available for Windows, Linux, and macOS that generates the MD5, SHA1, SHA256, and SHA512 of any file. It can be downloaded from https:/​/​quickhash-​gui.​org/​.

        -   **HashTab**: This tool runs in Windows and can be integrated as a tab in the properties information of a file. It calculates the MD5, SHA1, and a couple of hash algorithms.

        -   **7-zip**: This tool is actually a file archiver, but it has an extension tool that can be enabled to calculate the hash of a file in MD5, SHA1, SHA256, and so forth.

        -   **md5sum**: This is a Linux command used to calculate the MD5 hash of a given file.

    -   ## File Type and header analysis

        -   These tools gather primary information about a file. The data gathered includes the filename, file size, file type, and file type-specific properties. The result of these tools enables the analyst to plan how to analyze the file:

        -   **PEiD**: A tool used to identify the file type, the packer, and compiler. It is built to run in Windows. It is not maintained, but still very useful.

        -   **TrID**: A command-line tool similar to PEiD. This tool has Windows and Linux versions. It can read a community-driven signature database of various file types. **PEid and TrID** are the tools that are able to detect the type of file, the compiler used, the encrypting tool, and the packer and protector used. Compressed executables are better known as packers. Some examples of these packers are UPX, PECompact, and Aspack. Protectors, on the other hand, are somewhat like packers, but rather more advanced in the sense that the original compiled code would be protected from being reversed easily. Examples of protectors include Themida, AsProtect, and Enigma Protector.

        -   **CFF Explorer**: This tool is primarily used to read and make edits in a PE format file. It runs under Windows and has a lot of features, such as listing processes and dumping processes to a file. It can also be used to rebuild a process dump.

        -   **PE Explorer**: Another tool used to read and edit the structure of PE files. It can also unpack a number of executable compressed programs, such as UPX, Upack, and NSPack. PE Explorer only runs in Windows.

        -   **Detect-it-Easy (DiE):** Downloaded from https:/​/​github.​com/​horsicq/​Detect- It-​Easy, DiE is an open source tool that uses a community-driven set of algorithmic signatures to identify files. The tool has builds for Windows and Linux.

        -   **python-magic** : This is a Python module that is able to detect the file type. However, unlike PEiD and TrID, it also detects compilers and packers:

        -   **ExifTool**: This tool was primarily designed to read and edit the metadata of image files with an EXIF file format. It was further developed to extend features for other file formats, including PE files. ExifTool is available for Windows and Linux and can be downloaded from https:/​/​sno.​phy.​queensu.​ca/​\~phil/ exiftool/​.

        -   **file**: This is a command line in Linux used to identify files. It uses the libmagic library

    -   ## Imported DLLs and APIs text strings

        -   Text-string gathering tools are mainly used to quickly identify possible functions or messages used by the program. It is not always true that every text string is used by the program. Program flow still depends on conditions set in the program. However, the string locations in the file can be used as markers that the analyst can trace back:

        -   **\_SysInternals Suite\'s strings**: This is a command-line tool for Windows that shows the list of text strings in any type of file.

        -   **BinText**: This is a GUI-based Windows tool that can display the ASCII and Unicode text strings for any given file.

        -   **strings**: This is a Linux command used to list the strings found in a given file.

    -   ## What the file does

-   # malware techniques

    -   ## 1\]process injection

        -   this technique injects code into another running process, and that process unwittingly executes the malicious code. Malware authors use pro- cess injection in an attempt to conceal the malicious behavior of their code, and sometimes they use this to try to bypass host-based firewalls and other process-specific security mechanisms

        -   dll injection

            -   DLL injection---a form of process injection where a remote process is forced to load a malicious DLL

        -   direct injection

            -   Like DLL injection, direct injection involves allocating and inserting code into the memory space of a remote process. Direct injection uses many of the same Windows API calls as DLL injection. The difference is that instead of writing a separate DLL and forcing the remote process to load it, direct- injection malware injects the malicious code directly into the remote process.

            -   Direct injection is more flexible than DLL injection, but it requires a lot of customized code in order to run successfully without negatively impacting the host process. This technique can be used to inject compiled code, but more often, it's used to inject shellcode

    -   ## 2\]process replacement

    -   ## 3\]hook injection

    -   ## 4\]Apc injection
