<h1 align="center">ASSEMBLY LANGUAGE</h1>

-   # Introduction

    -   Every computer platform has its own assembly language that is usually quite different from all the rest Assembly language is simply a textual representation of machine code or binary code Each assembly language command is represented by a number, called the operation code, or opcode. Object code is essentially a sequence of opcodes and other numbers used in connection with the opcodes to perform operations.

    -   after assembler transfer our file to an object file which is a file contains hexadecimals only the linker tranform that object file to a binary file or executable one (opcode is the hex representation of assembly instructions)

    -   ## popular assembler:

        -   **Masm** : Microsoft Macro Assembler used in windows

        -   **Nasm** : NASM is the abbreviation of Netwide Assembler. Used most in unix based system

        -   **Fasm** : Flat Assembler,

    -   ## Linker

        -   ld : is a command line in linux that is a linker to be used after nasm to make a file executable

            -   nasm -f elf32 example.asm -o ex1.o // make an object file from assembly code

            -   ld -m elf\_i386 ex1.o ex1 // transform from object file to an executable file

            -   ld -o ProgramA ProgramA.o

            -   ld -m elf\_i386 -s -o hello hello.o

        -   opposite of linking and get the shellcode of the executable

            -   Objdump -d ProgramA -M intel

            -   for i in \`objdump -d ProgramA \| tr \'\\t\' \' \' \| tr \' \' \'\\n\' \| egrep \'\^\[0-9a-f\]{2}\$\' \` ; do echo -n \"\\x\$i\" ; done ; echo -e \"\\n\"

                -   get only the shellcode without the instructions

-   # REGISTERS:

    -   A register is a small amount of data storage available to the CPU, whose contents can be accessed more quickly than storage available elsewhere. x86 processors have a collection of registers available for use as temporary storage or workspace

    -   Registers names start with the letter E, which stands for extended. These register names have been carried over from the older 16-bit Intel architecture, where they had the exact same names, (so that EAX was called AX, etc.). This is important because sometimes you'll run into 32-bit code that references registers in that way: MOV AX, 0x1000,. Each register may contain a 32-bit value (allowing values between 0 and 0xFFFFFFFF) or may contain 16-bit or 8-bit values in the respective subregisters as shown in the EAX register EAX=AX/AH/AL

    -   Most common x86 registers, which fall into the following four categories:

        -   **General registers** are used by the CPU during execution.

        -   **Segment registers** are used to track sections of memory.

        -   **Status flags** are used to make decisions.

        -   **Instruction pointers** are used to keep track of the next instruction to execute.

    -   ## GENERAL PURPOSE REGISTERS :

        ![Registry](images/assembly/registers.png)

        -   All general registers are 32 bits in size and can be referenced as either 32 or 16 bits in assembly code. For example, EDX is used to reference the full 32-bit register, and DX is used to reference the lower 16 bits of the EDX register

        -   All these registers have an \"extended\" mode for 32-bits. It can accessed with a prefixed \"E\" (EAX, EBX, ECX, EDX, ESP, EIP, and EFLAGS). The same goes with 64-bit mode, which can be accessed with a prefixed \"R\" (RAX, RBX, RCX, RDX, RSP, and RIP).

            -   EAX (AX, AH, AL) = Accumulator Register

            -   EBX (BX, BH, BL) = Base Register

            -   ECX (CX, CH, CL) = Counter Register

            -   EDX (DX, DH, DL) = Data Register

            -   EBP (BP) = Base pointer Register

            -   ESP (SP) = Stack pointer Register

            -   ESI (SI) = Source index Register

            -   EDI (DI) = Destination index Register
    
            -   EIP = instruction pointer Register

        -   **EBP**: Can be used as a generic register, but is mostly used as the stack base pointer. Using a base pointer in combination with the stack pointer creates a stack frame. A stack frame can be defined as the current function's stack zone, which resides between the stack pointer (ESP) and the base pointer (EBP). The base pointer usually points to the stack position right after the return address for the current function. Stack frames are used for gaining quick and convenient access to both local variables and to the parameters passed to the current function.

        -   **ESP** This is the CPUs stack pointer. The stack pointer stores the current position in the stack, so that anything pushed to the stack gets pushed below this address, and this register is updated accordingly.

        -   **ESI/EDI** Generic, frequently used as source/destination pointers in instructions that copy memory and store memory addresses(SI stands for Source Index, and DI stands for Destination Index). ex if we want to copy a string from a place to another we will use ESI to store the memory address that contains the string now and the EDI will store the memory address that the string will be copied to

        -   **ECX** : for loop operations , counter register

        -   **EBX** : can be used in a lot of situation for storing data

        -   **EAX /EDX**: EAX generally contains the return value for function calls. Therefore, if you see the EAX register used immediately after a function call, you are probably seeing the code manipulate the return value. And EDX are you to store the variables of a functions and Both are used mostly for the multiplication and division also

    -   ## Flags registers (EFLAGS)

        -   IA-32 processors have a special register called EFLAGS that contains all kinds of status and system flags. In the x86 architecture, it is 32 bits in size, and each bit is a flag. During execution, each flag is either set (1) or cleared (0) to control CPU operations or indicate the results of a CPU operation

        -   Additionally, there are instructions that operate based on the values of these status flags, so that it becomes possible to create sequences of instructions that perform different operations based on different input values, and so on. In IA-32 code, flags are a basic tool for creating conditional code. There are arithmetic instructions that test operands for certain conditions and set processor flags based on their values. Then there are instructions that read these flags and perform different operations depending on the values loaded into the flags. One popular group of instructions that act based on flag values is the Jcc (Conditional Jump) instructions, which test for certain flag values (depending on the specific instruction invoked) and jump to a specified code address if the flags are set according to the specific conditional code specified. Let's look at an example to see how it is possible to create a conditional statement like the ones we're used to seeing in high-level languages using flags. Say you have a variable that was called bSuccess in the high-level language, and that you have code that tests whether it is false. The code might look like this:

            -   if (bSuccess == FALSE) return 0;

        -   What would this line look like in assembly language?

            -   It is not generally possible to test a variable's value and act on that value in a single instruction--- most instructions are too primitive for that. Instead, we must test the value of bSuccess (which will probably be loaded into a register first), set some flags that record whether it is zero or not, and invoke a conditional branch instruction that will test the necessary flags and branch if they indicate that the operand handled in the most recent instruction was zero (this is indicated by the Zero Flag, ZF). Otherwise the processor will just proceed to execute the instruction that follows the branch instruction. Alternatively, the compiler might reverse the condition and branch if bSuccess is nonzero.

        ![Registry](images/assembly/eflags_registers.jpg)

    -   ## Flags

        -  
 |     Offset   |     Abbreviation    |     Description                                                                                                                                                                                                                                                    |
|---------------|---------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|     0         |     CF              |           Carry flag.   This flag is set when an addition operation requires a bit to be carried. It   is also set when a bit needs to be borrowed in a subtraction operation.                                                                                     |
|     1         |                     |      Reserved                                                                                                                                                                                                                                                      |
|     2         |     PF              |     Parity flag.   This flag indicates if the number of set bits is odd or even from the last   instruction operation.                                                                                                                                             |
|     3         |                     |        Reserved                                                                                                                                                                                                                                                    |
|     4         |     AF              |     Adjust flag.   This is used in Binary-Coded Decimals (BCD). This flag is set when a carry   happens from the low to high nibble or when a borrow happens from the high to   low nibble of a byte.                                                              |
|     6         |     ZF              |     Zero flag. This   flag is set when the result of the last instruction operation is zero.                                                                                                                                                                       |
|     7         |     SF              |     Sign flag. This   flag is set when the result of the last instruction operation is a negative   number.                                                                                                                                                        |
|     8         |     TF              |     Trap flag. This   is used when debugging. This flag is set when breakpoints are encountered.   Setting the trap flag can cause an exception on every instruction, enabling   debugging tools to control step-by-step debugging.                                |
|     9         |     IF              |     IF Interrupt   flag. If this flag is set, the processor responds to interrupts. Interrupts   are instances where errors, external events, or exceptions are triggered from   hardware or software.                                                             |
|     10        |     DF              |     Direction flag.   When set, data is read from memory backwards.                                                                                                                                                                                                |
|     11        |     OF              |     Overflow flag.   It is set if an arithmetic operation results in a value larger than what the   register can contain.                                                                                                                                          |
|     12/13     |     IOPL            |     Input/output   privilege level. The IOPL shows the ability of the program to access IO ports                                                                                                                                                                   |
|     14        |     NTF             |     Nested task   flag. This controls the chaining of interrupt tasks or processes. If set,   then it is linked to the chain.                                                                                                                                      |
|     15        |                     |     Reserved                                                                                                                                                                                                                                                       |
|     16        |     RF              |     Resume flag. It   temporarily disables debug exceptions so the next instruction being debugged   can be interrupted without a debug exception.                                                                                                                 |
|     17        |     VM              |      VM Virtual mode. Sets the program to run in   compatibility with 8086 processors.                                                                                                                                                                             |
|     18        |     AC              |     Alignment   check. This flag is set when data written on a memory reference, such as the   stack, is a non-word (for 4 byte boundaries) or non-doubleword (for 8 byte   boundaries). However, this flag was more useful before the 486-architecture   days.    |
|     19        |     VIF             |     Virtual   interrupt flag. Similar to the interrupt flag, but works when in virtual   mode.                                                                                                                                                                     |
|     20        |     VIP             |     Virtual   interrupt pending flag. Indicates that triggered interrupts are waiting to be   processed. Works in Virtual mode.                                                                                                                                    |
|     21        |     ID              |     Identification   flag. Indicates if the CPUID instruction can be used. The CPUID can determine   the type of processor and other processor info.                                                                                                               |
|     22-63     |                     |     Reserved                                                                                                                                                                                                                                                       |
|               |                     |                                                                                                                                                                                                                                                                    |                            
        -   ## important flags

            -   ZF The zero flag is set when the result of an operation is equal to zero; otherwise, it is cleared.

            -   CF The carry flag is set when the result of an operation is too large or too small for the destination operand; otherwise, it is cleared.

            -   SF The sign flag is set when the result of an operation is negative or cleared when the result is positive. This flag is also set when the most significant bit is set after an arithmetic operation.
    
            -   TF The trap flag is used for debugging. The x86 processor will execute only one instruction at a time if this flag is set.

    -   ## Segment registers (track section of memory)

        -   The memory is divided into sections such as the code segment, stack segment, data segment, and other sections. The segment registers are used to identify the starting location of these sections, as follows:

            -   Stack segment (SS)

            -   Code segment (CS)

            -   Data segment (DS)

            -   Extra segment (ES)

            -   F segment (FS)

            -   G segment (GS)

        -   When a program loads, the operating system maps the executable file to the memory. The executable file contains information to which data maps respective segments. The code segment contains the executable code. The data segment contains the data bytes, such as constants, strings, and global variables. The stack segment is allocated to contain runtime function variables and other processed data. The extra segment is similar to the data segment, but this space is commonly used to move data between variables. Some 16-bit operating systems, such as DOS, make use of the SS, CS, DS, and ES since there are only 64 kilobytes allocated per segment. However, in modern operating systems (32-bit systems and higher) these four segments are set in the same memory space, while FS and GS point to process and thread information respectively.

    -   ## XMM registers

    -   ## MXX registers

-   # INSTRUCTION FORMAT :

    -   Instructions usually consist of an **opcode** (operation code), and one or two operands. The opcode is the hex representation of an instruction name such as MOV, and the operands are the "parameters" that the instruction receives (some instructions have no operands). Every instruction has an equivalent opcode (operation code) byte:

        -   Instruction mov ecx, 0x42

        -   Opcodes B9 42 00 00 00

    -   every instructions in assembly is called mnemonic and its being transformed to opcodes which is a machine code but in hex format

    -   so every source code we write will be translated in the end into assembly code that is composed of some Mnemonics after that these Mnemonics will be translated to opcode which is machine code represented in hex and in the end the opcode will be transformed from Hex to Binary that will be executed by the cpu

        -   in metasploit there is a tool called metasm that translates assembly to opcode and we use it sometimes in building shellcode

    -   Naturally, each instruction requires different operands because they each perform a different task. Operands represent data that is handled by the specific instruction (just like parameters passed to a function), and in assembly language, **operands comes in three basic forms:**

        -   **Register name:** The name of a general-purpose, this would be something like EAX, EBX, and so on.

        -   **Immediate**: e fixed values, such as the 0x42, A constant value embedded right in the code. This often indicates that there was some kind of hard-coded constant in the original program.

        -   **Memory address**: When an operand resides in RAM, its memory address is enclosed in brackets to indicate that it is a memory address. The address can either be a hard-coded immediate that simply tells the processor the exact address to read from or write to or it can be a register whose value will be used as a memory address. It is also possible to combine a register with some arithmetic and a constant, so that the register represents the base address of some object, and the constant represents an offset into that object or an index into an array.

        -   The general instruction format looks like this:

            -   Instruction Name (opcode) Destination Operand, Source Operand

            -   Some instructions only take one operand, whose purpose depends on the specific instruction. Other instructions take no operands and operate on predefined data.

            -   Ex : message db 0xAA 0xBB

            -   mov eax , message      -\> moves address into eax

            -   mov ebx , \[message\]     -\>moves value in message to ebx

            -   mov eax ,  ax045          -\> moves data into register

-   # BASIC INSTRUCTIONS :

    -   Assembly language instructions can be categorized as follows:

        -   Copying and accessing data instructions (for example, MOV, LEA, and MOVB)

        -   Arithmetic instructions (for example, ADD, SUB, MUL, and DIV)

        -   Binary logic instructions (for example, XOR, NOT, SHR, and ROL)

        -   Flow control (for example, JMP, CALL, CMP, and INT)

    -   ## MOVE INSTRUCTIONS

        -   MOV DestinationOperand, SourceOperand

            -   MOV takes two operands: a destination operand and a source operand, and simply moves data from the source to the destination.

        -   XCHG REGISTER , REGISTER

            -   exchange or swap the values between the 2 registers

        -   LEA register , \[label\]     

            -   Lea = load effective address , load pointer values , The lea instruction is used to put a memory address into the destination

            -   lea destination, source

            -   lea ebx , \[eax\]

    -   ## ARITHMETIC INSTRUCTIONS:

        -   **Add instruction**

            -   ADD Operand1, Operand2 \[add destination, value.\]

            -   Adds two signed or unsigned integers. The result is typically stored in Operand1.

            -   we have register based arthmetic 

                -   mov eax , 0x55

                -   add  eax , 0x43    //add these 0x43 to the value in the eax register

            -   memory based arithmetic

                -   var1 : db 0x00

                -   add byte \[var1\] , 0x33    //add 0x33 to the value in var1

        -   **SUB instruction**

            -   SUB Operand1, Operand2

            -   Subtracts the value at Operand2 from the value at Operand1. The result is typically stored in Operand1. This instruction works for both signed and unsigned operands.

        -   **INC/DEC instructions**

            -   INC operand    //increment a register by one

            -   DEC OPERAND   //decrement a register by one

        -   **MUL/DIV/IMUL/IDIV instructions**

            -   MUL Operand

                -   Multiplies the unsigned operand by EAX and stores the result in a 64-bit value in EDX:EAX. EDX:EAX means that the low (least significant) 32 bits are stored in EAX and the high (most significant) 32 bits are stored in  EDX. This is a common arrangement in IA-32 instructions.

                -   EX : mul 0x50 Multiplies EAX by 0x50 and stores the result in EDX:EAX

            -   DIV Operand

                -   Divides the unsigned 64-bit value stored in EDX:EAX by the unsigned operand. Stores the quotient in EAX and the remainder in EDX.

                -   EX: div 0x75 Divides EDX:EAX by 0x75 and stores the result in EAX and the remainder in EDX

            -   IMUL Operand

                -   Multiplies the signed operand by EAX and stores the result in a 64-bit value in EDX:EAX.

            -   IDIV Operand

                -   Divides the signed 64-bit value stored in EDX:EAX by the signed operand. Stores the quotient in EAX and the remainder in EDX.

    -   ## Cmp instruction

        -   CMP Operand1, Operand2

        -   compare 2 operands CMP records the result of the comparison in the processor's flags. CMP simply subtracts Operand2 from Operand1 and discards the result, while setting all of the relevant flags to correctly reflect the outcome of the subtraction. For example, if the result of the subtraction is zero, the Zero Flag (ZF) is set, which indicates that the two operands are equal. The same flag can be used for determining if the operands are not equal, by testing whether ZF is not set. There are other flags that are set by CMP that can be used for determining which operand is greater, depending on whether the operands are signed or unsigned

            -   cmp dst, src ZF CF

            -   dst = src 1 0

            -   dst \< src 0 1

            -   dst \> src 0 0

    -   ## control instructions

        -   uses flags to determine decisions

        -   branching :  (GOTO statement in c)

        -   unconditional jump   

            -   jmp location

            -   Causes the next instruction executed to be the one specified by the jmp. execution will always transfer to the target location with no condition specified

            -   Ex: 

                -   JMP lable5 

                -   lable5 :

        -   Conditional jump

            -   conditional jxx           

            -   jump to an instruction based on a decision and different states of flages (used in if conditions)

            -   Jcc TargetCodeAddress

                -   conditional branche If the specified condition is satisfied, Jcc will just update the instruction pointer to point to TargetCodeAddress(without saving its current value). If the condition is not satisfied, Jcc will simply do nothing, and execution will proceed at the following instruction.

            -    Ex of popular conditional jmp

                -   jz loc = Jump to specified location if ZF = 1.

                -   jnz loc = Jump to specified location if ZF = 0.

                -   je loc = Same as jz, but commonly used after a cmp instruction. Jump will occur if the destination operand equals the source operand.

                -   jne loc = Same as jnz, but commonly used after a cmp. Jump will occur if the destination operand is not equal to the source operand.

                -   jg loc = Performs signed comparison jump after a cmp if the destination operand is greater than the source operand.

                -   jge loc = Performs signed comparison jump after a cmp if the destination operand is greater than or equal to the source operand.

                -   ja loc = Same as jg, but an unsigned comparison is performed.

                -   jae loc = Same as jge, but an unsigned comparison is performed.

                -   jl loc = Performs signed comparison jump after a cmp if the destination operand is less than the source operand.

                -   jle loc = Performs signed comparison jump after a cmp if the destination operand is less than or equal to the source operand.

                -   jb loc = Same as jl, but an unsigned comparison is performed.

                -   jbe loc = Same as jle, but an unsigned comparison is performed.

                -   jo loc = Jump if the previous instruction set the overflow flag (OF = 1).

                -   js loc = Jump if the sign flag is set (SF = 1).

                -   jecxz loc = Jump to location if ECX = 0

    -   ## logical instructions(operators) :

        -   AND operand1 , operand2   //the result will be stored in operand 1

        -   OR     operand1 , operand2

        -   XOR   operand1 , operand2

        -   NOT    operand1 , operand2

        -   SHL/SAL

            -   This operation shifts bits to the left.

            -   Consider the following as an example:

            -   SHL AL, 3

            -   If AL were 11011101b (DDh), shifting it to the left by 3 makes AL equal to 11101000b (E8h).

        -   SHR/SAR

            -   This operation shifts bits to the right.

            -   Consider the following as an example:

            -   SHR AL, 3

            -   If AL were 11011101b (DDh), shifting it to the right by 3 makes AL equal to 011011b (1Bh).

        -   ROL

            -   This operation rotates bits to the left.

            -   Consider the following as an example:

            -   ROL AL, 3

            -   if AL were 11011101b (DDh), rotating it to the left by 3 makes AL equal to 11101110b (EEh).

        -   ROR

            -   This operation rotates bits to the right.

            -   Consider the following as an example:

            -   ROR AL, 3

            -   If AL were 11011101b (DDh), rotating it to the right by 3 makes AL equal to 10111011b (BBh).

    -   ## NOP instruction

        -   nop, does nothing. When it's issued, execution simply proceeds to the next instruction. The instruction nop is actually a pseudonym for xhcg eax, eax, but since exchanging EAX with itself does nothing, it is popularly referred to as NOP (no operation). The opcode for this instruction is 0x90. It is commonly used in a NOP sled for buffer overflow attacks, when attackers don't have perfect control of their exploitation. It provides execution padding, which reduces the risk that the malicious shellcode will start executing in the middle, and therefore malfunction

        -   **NOP sled** (also known as a NOP slide) is a long sequence of instructions pre- ceding shellcode,. NOP sleds are not required to be present with shellcode, but they are often included as part of an exploit to increase the likelihood of the exploit succeeding. Shellcode authors can do this by creating a large NOP (0x90) sled immediately preceding the shellcode. As long as execution is directed somewhere within the NOP sled, the shellcode will eventually run.

    -   ## Rep Instructions

        -   Rep instructions are a set of instructions for manipulating data buffers. They are usually in the form of an array of bytes, but they can also be single or double words. We will focus on arrays of bytes in this section. (Intel refers to these instructions as string instructions, but we won't use this term to avoid confusion with the strings we discussed in Chapter 1.) The most common data buffer manipulation instructions are movsx, cmpsx, stosx, and scasx, where x = b, w, or d for byte, word, or double word, respectively. These instructions work with any type of data, but our focus in this section will be bytes, so we will use movsb, cmpsb, and so on. The ESI and EDI registers are used in these operations. ESI is the source index register, and EDI is the destination index register. ECX is used as the counting variable. These instructions require a prefix to operate on data lengths greater than 1. The movsb instruction will move only a single byte and does not utilize the ECX register.

        -   In x86, the repeat prefixes are used for multibyte operations. The rep instruction increments the ESI and EDI offsets, and decrements the ECX register. The rep prefix will continue until ECX = 0. The repe/repz and repne/ repnz prefixes will continue until ECX = 0 or until the ZF = 1 or 0. This is illustrated in Table 4-10. Therefore, in most data buffer manipulation instructions, ESI, EDI, and ECX must be properly initialized for the rep instruction to be useful.

            -   **Instruction Description**

            -   rep Repeat until ECX = 0

            -   repe, repz Repeat until ECX = 0 or ZF = 0

            -   repne, repnz Repeat until ECX = 0 or ZF = 1

        -   The movsb instruction is used to move a sequence of bytes from one location to another. The rep prefix is commonly used with movsb to copy a sequence of bytes, with size defined by ECX. The rep movsb instruction is the logical equivalent of the C memcpy function. The movsb instruction grabs the byte at address ESI, stores it at address EDI, and then increments or decrements the ESI and EDI registers by one according to the setting of the direction flag (DF). If DF = 0, they are incremented; otherwise, they are decremented. You rarely see this in compiled C code, but in shellcode, people will sometimes flip the direction flag so they can store data in the reverse direction. If the rep prefix is present, the ECX is checked to see if it contains zero. If not, then the instruction moves the byte from ESI to EDI and decrements the ECX register. This process repeats until ECX = 0.

        -   The cmpsb instruction is used to compare two sequences of bytes to determine whether they contain the same data. The cmpsb instruction subtracts the value at location EDI from the value at ESI and updates the flags. It is typically used with the repe prefix. When coupled with the repe prefix, the cmpsb instruction compares each byte of the two sequences until it finds a difference between the sequences or reaches the end of the comparison. The cmpsb instruction obtains the byte at address ESI, compares the value at location EDI to set the flags, and then increments the ESI and EDI registers by one. If the repe prefix is present, ECX is checked and the flags are also checked, but if ECX = 0 or ZF = 0, the operation will stop repeating. This is equivalent to the C function memcmp.

        -   The scasb instruction is used to search for a single value in a sequence of bytes. The value is defined by the AL register. This works in the same way as cmpsb, but it compares the byte located at address ESI to AL, rather than to EDI. The repe operation will continue until the byte is found or ECX = 0. If the value is found in the sequence of bytes, ESI stores the location of that value.

        -   The stosb instruction is used to store values in a location specified by EDI. This is identical to scasb, but instead of being searched for, the specified byte is placed in the location specified by EDI. The rep prefix is used with scasb to initialize a buffer of memory, wherein every byte contains the same value. This is equivalent to the C function memset

-   # Data types in assembly :

    -   bytes : 8 bits              -\>1 byte

    -   word : 16 bits              -\>2 bytes

    -   double word : 32 bits    -\>4 bytes

    -   quad word : 64 bits        -\>8 bytes

    -   double quad word : 128 bits -\>16 bytes

-   # defining initialized data :

    -   label:    db \<0x055\>                    

        -   db -\> define a byte

    -   label2: db \<0x055\>,\<0x05\>,\<0x053\>        

        -   define 3 byte

    -   message:   db \'hello word\'    

        -   we can define a string

    -   message2:   dw \<0x01243\>                  

        -   dw -\> define a word  0x43 0x12 = 2 bytes

    -   message2:   dw \'ab\'                 

        -   define a word this will be translated to hexadecimal and stored as 0x61 ox62   which are the representation of a and b in hexadecimal

    -   label5:   dd \<\>                  

        -   dd - \> define a double word = 4 bytes

    -   label6:    dq  \<\>

        -   dq -\> define a quad word = 8 bytes

    -   label7:  dt  \<\>

        -   // TIMES \<NB\>  \<instruction\>     //repeat that instruction nb of times

        -   //when storing an signed value in a double word we use the final bit to indicate if its negative or positive

-   # declare uninitialized variable : (found in .bss section)

    -   There are 5 basic forms of declaring a variable

        -   RESB = Reserve a Byte

        -   RESW = Reserve a word

        -   RESD = Reserve a double word

        -   RESQ = Reserve a Quad word

        -   REST = Reserve ten words

    -   Example :

        -   buffer :            resb           64           

            -   reserve a 64 byte     

        -   wordvar :          resw         \`  1           

            -   reserve a 1 word

-   # Constant Variables

    -   There are several methods to define a constant the most used are

        -   EQU

        -   %assign

        -   %define

    -   **EQU**

        -   Const\_Name EQU expression

        -   Ex :

            -   Len equ 20

    -   **%assign**

        -   Used to define integers constants

        -   Ex :

            -   %assign len 10

    -   **%define**

        -   Used to define integers and strings constants

        -   Ex :

            -   %define anything 10

-   # Function in Assembly

    -   ## Function Definition

        -   ### Function prologue and epilogue

            -   **prologue**

                -   a few lines of code at the start of the function. The prologue prepares the stack and registers for use within the function.

                -   What these instruction do:

                    1.  save the value of the EBP register on the stack, so after the functions terminates it return back to the old stack of the previous function

                    2.  set the value of the EBP register to the value of the ESP , basafer el stack =0 3ashan a create a new stack for the new function

                    3.  Allocate space on the stack for local variables.

                -   Ex

                    -   push ebp

                    -   mov ebp, esp ; ebp now points to the top of the stack

                    -   sub esp, X

                        -   X is the total size, in bytes, of all local variables used in the function and we subtract not add because the stack growth is reversed from high address to lower address x is any nb divisible by 4

                        -   sub esp, 0 ; no local variables, most compilers will omit this line

                -   we can replace \[push ebp , mov ebp, esp \] with **Enter** instruction  

            -   **epilogue**

                -   at the end of a function restores the stack and registers to their state before the function was called.

                -   The function epilogue

                    -   frees the allocated space in the stack,

                    -   returns the value in the EBP register back to its initial state

                    -   returns the control flow to the caller

                -   Example

                    -   mov esp, ebp

                    -   pop ebp

                    -   ret 0

                        -   restore the EIP value

                -   we can replace \[mov esp, ebp , pop ebp \] with **leave** instruction

        -   ### Ex of a procedure or function:

            -   PROCEDURE\_NAME:

            -     \..... PROCEDURE BODY\....

            -    \.....CODE\....

            -   RET   

                -   end of the procedure and go back to the next instruction line where this procedure was called  pop the EIP that was pushed when called the fn

        -   ### Local variables

            ![arguments](images/assembly/function_arguments.jpeg)

            -   local variables can be accessed by referencing ebp

            -   Ex: C code

                -   void MyFunction(){

                -   int a, b, c;

                -   a = 10;

                -   b = 5;

                -   c = 2; }

            -   it's representation in assembly:

                -   Push ebp ; save the value of ebp

                -   Mov ebp , esp. ; ebp now points to the top of the stack

                -   Sub esp , 12. ; space allocated on the stack for the local variables we have 3 variables so 3\*4 = 12

                -   mov \[ebp - 4\], 10 ; location of variable a

                -   mov \[ebp - 8\], 5 ; location of b

                -   mov \[ebp - 12\], 2 ; location of c

                    -   \[ebp + 16\] (third argument)

                    -   \[ebp + 12\] (2nd argument)

                    -   \[ebp + 8\] (1st argument)

                    -   \[ebp + 4\] (return address)

    -   ## Function calls

        -   System call is a call to a subroutine built in to the system, while a function call is a call to a subroutine within the program.

        -   Every function has it own stack we should save our program state before going to function 

        -   **CALL Function\_Address or procedure\_name**

            -    Function calls are implemented using two basic instructions in assembly language. The CALL instruction calls a function, and the RET (Return) instruction returns execution to the caller the caller will take the result from the EAX register.

            -   The CALL instruction

                -   pushes the EIP or the next instruction  onto the stack (so that it is later possible to return to the caller)

                -   Jumps to the specified address. The function's address can be specified just like any other operand, as an immediate, register, or memory address

                -   places the value of the parameter into the EAX register, which is used by convention for storing the return value

            -   Call and RET equivalent

                -   The CALL instruction is equivalent to a

                    -   PUSH address\_after\_call / JMP operand instruction pair.

                -   The REt instruction is equivalent to a

                    -   a POP tmp / JMP tmp instruction pair

        -   **Pushing arguments**

            -   An API function is set up by placing the arguments in the memory stack space before calling a Function. If your program is built in C, a function that requires 3 parameters (for example, myfunction(arg1, arg2, arg3)) will have the following as an equivalent in assembly language:

                -   push \<arg3\>

                -   push \<arg2\>

                -   push \<arg1\>

                -   call myfunction

            -   C code :

                -   MyFunction2(10, 5, 2);

            -   Assembly code

                -   push 2

                -   push 5

                -   push 10

                -   call \_MyFunction2

                    -   note that we are using a Right-to-Left calling convention called CDECL

    -   **Example of a function code**

        -   C code :

            -   \_cdecl int MyFunction1(int a, int b) { return a + b; }

            -   x = MyFunction1(2, 3);

        -   Assembly code

            -   \_ MyFunction1

            -   Push ebp

            -   Mov ebp , esp

            -   Mov eax , \[ebp+8\]

            -   Mov edx , \[ebp+12\]

            -   Add eax , edx

            -   Mov esp , ebp

            -   Pop ebp

            -   Ret

            -   .

            -   Push 3

            -   Push 2

            -   Call MyFunction1

            -   Sub esp , 8

        -   ADD ESP, 4 is effectively equivalent to POP register but without using any register

        -   **implementation for function calls**

            1.  Arguments are placed on the stack using push instructions.

            2.  A function is called using call memory\_location. This causes the current instruction address (that is, the contents of the EIP register) to be pushed onto the stack. This address will be used to return to the main code when the function is finished. When the function begins, EIP is set to memory\_location (the start of the function).

            3.  Through the use of a function prologue, space is allocated on the stack for local variables and EBP (the base pointer) is pushed onto the stack. This is done to save EBP for the calling function.

            4.  The function performs its work.

            5.  Through the use of a function epilogue, the stack is restored. ESP is adjusted to free the local variables, and EBP is restored so that the calling function can address its variables properly. The leave instruction can be used as an epilogue because it sets ESP to equal EBP and pops EBP off the stack.

            6.  The function returns by calling the ret instruction. This pops the return address off the stack and into EIP, so that the program will continue executing from where the original call was made.

            7.  The stack is adjusted to remove the arguments that were sent, unless they'll be used again later

        -   **Resources**

            -   https://en.m.wikibooks.org/wiki/X86\_Disassembly/Functions\_and\_Stack\_Frames

-   # Systemcalls in Assembly (API function)

    -   ## Definition

        -   System calls are used to make and facilitate our program to interact with the kernel and not to write a code from scratch to print to screen or exit etc\... they are APIs for the interface between the user space and the kernel space

        -   as we see that the memory is divided into user space and kernel space and the user space is responsible of the programs that the user open and this division is for protecting the operating system from anything being functioned by the user imagine that the user can control the code of the os inside the kernel it could crash the OS so how programs in the user space communicate with the kernel space?

        -   this can happen with (system calls) which is the link between the user space and kernel space and there is no other way than system calls for the user space to communicate with the kernel space Example :

        -   if we are writting c code that prints hello world . when this program start it will be loaded in the user space but the program contains a print function and printing to screen is the responsibility of the operating system or the kernel to be specific

        -   the program will use (system calls/windows api) to tell the kernel to do the printing function , and in the end the kernel will return the result to program in the user space

        -   someone could wonder how system calls are used and the programmer didn't use them in the code and the answer is that when we used printf() function in c language a system call called write() is executed automatically and it is the responsible of the real printing function

        -   system calls which is used in Unix systems is called windows API in windows OS that do the same function

        -   All the syscalls are listed in /usr/include/asm/unistd.h, together with their numbers

     ![kernal space](images/operating_system/user-space.png)

    -   ## How to invoke a system call in a program

        1.  put the system call number that you want to use in EAX register

            -   system call numbers Example

                -   mov ax , 0x01                             //to exit  the program

                -   mov ax , 0x04                              //to write on screen

        2.  Put the arguments needed by the system call one by another in order in Registers {EBX,ECX,EDX,ESI,EDI}

        3.  invoke the system call by using the interrupt \[ Int 0x80 \] or SYSENTER  and this is the way that the programs in user space use to interact with kernel

        4.  The result is usually returned in the EAX register.

        ![kernal space](images/assembly/syscalls_nb.png)
        ![kernal space](images/assembly/registers_before_syscall.png)

    -   ## Example of some well-known syscalls

        -   write ( int  fd , const void \*buf , size\_t count )   //write system call

            -   we can use " man 2 write " to see the argument that this function takes

            -   **int fd** : which is the number of the file descriptor that points on the place that the string will be printed on and the number 1 in file descriptor means prints on stdout (screen)

            -   **const void \*buf** : which is the pointer in memory that contains the string that will be printed so if we want to print any string we will see the memory address that this string is stored in and use it here

            -   **size\_t count** : the lenght of the string that will be printed

                -   EAX= syscall nb         

                -   EBX=stdout         

                -   ECX =pointer to  \'hello world\'             

                -   EDX =lenght of \"hello word\"  

                    -   Then invoke the syscall = int 0x80

        -   void \_Exit(int status);​ // Exit system call

            -   we can use " man 2 exit " to see the argument that this function takes and we will notice that it takes only one argument

            -   **int status** : shows the status of the exit function , the number 0 is used to indicated the termination of the process successfully \[equivalent to return 0;\] any number other than 0 indicates that there is a problem

        ![kernal space](images/assembly/syscall-api.png)

    -   ## Code Example

        -   Global \_start

        -   section .text

        -   \_start:

        -   ;Write() Syscall

        -   mov eax, 0x4 ; 4 = write() syscall number

        -   mov ebx, 0x1 ; 1 = stdout = print to the screen

        -   mov ecx, message ; message is a pointer to the string \"Speak Less, Listen More\"

        -   mov edx, 24 ; length of \"Speak Less, Listen More\" + "0xA" = 24 in decimal

        -   int 0x80 ; Invoke the syscall

        -   

        -   ;Exit() Syscall

        -   mov eax, 0x1 ; 1 = exit() syscall number

        -   mov ebx, 0x0 ; 0 = return value. It could be anything, but we picked 0 to indicate clean exit

        -   int 0x80 ; Invoke the syscall

        -   

        -   section .data

        -   message: db \"Speak Less, Listen More\", 0xA

            -   ; declare \"message\" , assign the string to it and append 0xA to print on new line.

    -   instead of systemcalls we can include some c libraries {libc} by extern instruction

        -   ex :

            -   extern printf

            -   extern exit

-   # Windows Api

    -   Windows api differs with system calls in the way we use registers and the way we call the windows api

    -   **So these are the steps needed to invoke a windows api:**

        -   determine the Api that we want to use, and located in which dll file

        -   know the parameters or arguments required by the windows api and pushes them into the stack in order

        -   know the memory address of the windows api in the dll file and put it into any register

        -   call the register that contains the memory address of the api

    -   **How to know the memory address of a windows Api?**

        -   we will use a tool in windows called "arwin.exe" to know the memory address of an windows api

        -   We will use this command on the os that the shell code will work on :

        -   Arwin.exe \[dll file name\] \[windows api fn\]

        -   Ex: arwin.exe kernel32.dll ExitProcess

    -   **Notes**

        -   Note that these memory addresses will differ from one os and another ex the memory address of windows api in windows vista is different from windows 7 or 10

        -   This site contains all windows api that we will use

            -   https://msdn.microsoft.com/en-us/library/ff818516(v=vs.85).aspx

        -   Before using api we must know that every windows api is found in one of the dll files of the os Ex : MessageBox is found inside User32.dll , and ExitProcess is found inside Kernel32.dll and to know the corresponding dll file of any windows api we will find that in microsoft website what has a full documentation of windows apis

    -   **Example of some Windows Apis**

        -   **MessageBox**

            -   int WINAPI MessageBox (hWnd, lpText, lpCaption, uType)

                -   hwnd : is the handler to the owner window in our case there is no owner window so we will use NULL

                -   ipText : is the message that will be printed

                -   ipCaption : is the caption/title of the windows that will show the message

                -   uTYpe : and this is the option that will show inside the button ex we will have a button wriiten on it {ok , cancel , try , help ,\...} 0x00000004L this value is for yes/no

        -   **ExitProcess**

            -   Void WINAPI ExitProcess(uExitCode);

                -   this api only have one argument which is uExitCode and we will use 0 as we have chosen in Exit system call to show a clean Exit

        -   **Assembly code**

            -   global \_start

            -   section .text

            -   \_start:

            -   ;EAX will hold MessageBoxA memory address \"0x7642d619\"

            -   ;EBX will hold \"uType\" = \"0x00000004\" = \"Yes \| No\"

            -   ;ECX will hold \"lpCaption\" = \"Message From Nakerah Network\"

            -   ;EDX will hold \"lpText\" = \"Speak Less, Listen More\"

            -   ;\"hWnd\" will be set to null = no owner window

            -   

            -   mov eax, 0x7642d619 ;set EAX to memory address of \"MessageBoxA()\"

            -   xor ebx, ebx ;null the register

            -   mov bl, 0x4 ;set EBX to 0x4 = Yes OR No buttons

            -   xor esi, esi ;null ESI register to use it whenever we need to push null byte

            -   push esi ;pushing the string \"Message From  Network\" ending with null byte

            -   push dword 0x6b726f77

            -   push dword 0x74654e20

            -   push dword 0x68617265

            -   push dword 0x6b614e20

            -   push dword 0x6d6f7246

            -   push dword 0x20656761

            -   push dword 0x7373654d

            -   mov ecx, esp ;ECX now contains the address of \"Message From  Network\"

            -   push esi ;pushing the string \"Speak Less, Listen More\" ending with null byte

            -   push dword 0x2065726f

            -   push dword 0x4d206e65

            -   push dword 0x7473694c

            -   push dword 0x202c7373

            -   push dword 0x654c206b

            -   push dword 0x61657053

            -   mov edx, esp ;EDX now contains the address of \"Speak Less, Listen More\"

            -   

            -   ;Preparing the stack before calling MessageBoxA()

            -   push ebx ;Yes \| No

            -   push ecx ;\"Message From  Network\"

            -   push edx ;\"Speak Less, Listen More\"

            -   push esi ;hWnd = 0 = no owner window

            -   call eax ;call \"MessageBoxA()\"

            -   

            -   ;Preparing the stack before calling ExitProcess

            -   mov eax, 0x076073b54 ;set EAX to the memory address of \"ExitProcess()\"

            -   push esi ;ESI = 0 = return value

            -   call eax ;call \"ExitProcess()\"

-   # Recognizing c/c++ code construct in Assembly

    -   **Recognize Global/local variables**

        -   Global variables can be accessed and used by any function in a program. Local variables can be accessed only by the function in which they are defined. Both global and local variables are declared similarly in C, but they look completely different in assembly.

        -   The global variables are referenced by memory addresses, and the local variables are referenced by the stack addresses.

        -   **Assembly code**

            -   Global :

                -   mov eax, dword\_40CF60

                -   add eax, dword\_40C000

                -    mov dword\_40CF60, eax

            -   Local :

                -   mov dword ptr \[ebp-4\], 0

                -   mov dword ptr \[ebp-8\], 1

                -   mov eax, \[ebp-4\]

                -   add eax, \[ebp-8\]

    -   **Recognize if conditions**

        -   **C code**

            -   If condition

                -   if (condition) then

                -   do\_action

            -   If else conditions

                -   if (condition) then

                -   do\_action

                -   else

                -   do\_alternative\_action;

            -   Example 1

                -   if(x == 10){

                -   x=1;

                -   }

                -   X++

            -   Example 2

                -   if(x == 10) {

                -   x = 0;

                -   }

                -   else {

                -   x++;

                -   }

        -   **Assembly code**

            -   What to search for in code :

                -   A compare instruction, like \"cmp\", compares two values.  Internally, it does this by subtracting them.

                -   A conditional jump instruction, like \"je\" (jump-if-equal), does a goto somewhere if the two values satisfy the right condition.

            -   Steps :

                -   Initializing a variable

                -   **cmp**

                -   **condition jump ex: jnz location\_name**

                    -   if condition is true continue else jump to location specified

                -    ----code------

                -   **Location\_name :**

                -     ---code---

            -   Example 1 in assembly :

                -   Mov eax , \$x

                -   Cmp eax , 0

                -   Jne end ;

                -   Mov eax , 1

                -   \_end :

                -   Inc eax

                -   Mov \$x , eax

            -   Example 2 in assembly

                -   mov eax, \$x

                -   cmp eax, 0x0A ; 0x0A = 10

                -   jne else

                -   mov eax, 0

                -   jmp end

                -   else:

                -   inc eax

                -   end:

                -   mov \$x, eax

    -   **Recognize loops**

        -   **For loop**

            -   **C code**

                -   sum = 0;

                -   for (i = 0; i \<= 10; i++) {

                -   sum += I }

            -   **Assembly**

                -   mov eax, 0 ; eax is sum

                -   mov ebx, 0 ; ebx is i

                -   loop\_start:

                -   cmp ebx, 10 ; compare i and 10

                -   jg loop\_end ; if (i\>10) go loop\_end

                -   add eax, ebx ; sum += i

                -   inc ebx ; i++

                -   jmp loop\_start ; goto loop\_start

                -   loop\_end:

        -   **While loop**

            -   **c code**

                -   while (condition) {

                -   body

                -   }

            -   **Assembly code**

                -   while:

                -   cmp

                -   jxx end\_while ; branches if ; condition=false

                -   \--body of loop\--

                -   jmp while

                -   end\_while

        -   **Do while loop**

            -   **C code**

                -   do {

                -   body

                -   } while (condition)

            -   **Assembly code**

                -   do:

                -   \-- body of loop\--

                -   cmp

                -   jxx do ; branches if condition=true

        -   **Loop instruction**

            -   The LOOP instruction "LOOP LABEL "assumes that the **ECX register contains the loop count**. When the loop instruction is executed, the ECX register is decremented and the control jumps to the target label, until the ECX register value, i.e., the counter reaches the value zero.

            -   Example :

                -   mov ECX,10

                -   loop1:

                -   \<loop body\>

                -   loop loop1

-   # EX OF A PROGRAM :

    -   Global  \_start

    -   section .text :

        -   \_start                                  ;the entry point of the program  same as main in c

        -   ;print hello world to screen

        -   mov eax , 0x04       ;always eax will has the syscall of the function the syscall of write fn is 0x04       

        -   mov ebx , 0x01

        -   mov ecx , message

        -   mov edx , 12

        -   mov edx , message\_lenght                         ;or 12

        -   int 0x080 ;exit the program

        -   mov eax  , 0x01

        -   mov ebx , 0x00                    ;return 0

        -   int 0x080

    -   section .data :                                    ;where we put our initialized data

        -   message : db  \"hello world\"

        -   message\_lenght  EQ   \$-message

    -   setion  .bss :                                     ;where we put our uninitialized data

        -   var3:   resb      100   ; reserve 100 bytes

        -   var4 :   resw     20     ;reserve 20 words

-   # Calculating string length

    -   We can store the string length explicitly by using the \$ location

    -   \$ points to the byte after the last character of the string variable msg. Therefore, \$-msg gives the length of the string

    -   Example :

        -   msg db \'Hello, world!\',0xa ; our string

        -   len equ \$ - msg ;length of the string

            -   len equ \$ - msg = = len equ 13

-   <h1 align="center">Shellcoding</h1>

    -   # Definition

        -   Shellcode refers to a payload of raw executable code. The name shellcode comes from the fact that attackers would usually use this code to obtain interactive shell access which is (cmd in case of windows and terminal in case of linux ) on the compromised system. However, over time, the term has become commonly used to describe any piece of self-contained executable code. But Shellcode is nothing but some machine code

        -   Shellcode is defined as a set of instructions injected and then executed by an exploited program. Shellcode is used to directly manipulate registers and the functionality of a exploited program

    -   # Bad characters

        -   are characters that stops your shell codes or makes your shell code doesn't work so you need to remove them from your shell code . every program has his own bad characters ex: x00(null byte) is always a bad character

        -   **Null byte**

            -   the reason of finding a null byte which is a bad character that can crash our shellcode is that the size of the register is 32 bit (4 byte) so if the value that will be put in the register is smaller than 4 bytes, the other bytes non used in the register will be filled up with zeros and this is the reason of null byte appearance

            -   this issue can be solved by only using part of the register depending on the data that we want to store Ex :

                -   if we want to save 04 in EAX we can use AL instead of EAX because 04 will fill only 1 byte

                    -   mov Al ,0x4

                -   and this will give us the same result but while using a shellcode without null bytes

            -   This method is effective except in one condition, in many cases we want to store the value x00 in any register such as in Exit system call . in this case if we used mov AL, 0x0 we will find that our shellcode will contain a null byte so to solve that instead of using mov AL,0x0 we will use **XOR AL , AL** Because as we know that the result of xoring any register with itself is zero thus we have put the value x00 inside the register without resulting in a nullbyte

            -   **to summarize when writing a shellcode :**

                -   clear any register before using it by using xoring the register with himself to clear any past values stored in it

                -   don't use part of a register that is bigger than the value we want to store in it by using AL,BL,CL,DL

                -   using xor when we want to store a nul byte (x00) inside any register and avoid putting x00 directly

    -   ## C code to execute/try any shellcode

        -   /\* ShellcodeTester.c \*/

        -   \#include\<stdio.h\>

        -   \#include\<string.h\>

        -   

        -   char code\[\] = \"Paste Your Shellcode Here\";

        -   int main(int argc, char \*\*argv) {

        -   printf(\"Shellcode Length: %d\\n\", strlen(code));

        -   int (\*func)();

        -   func = (int (\*)()) code;

        -   (int)(\*func)();

        -   }

            -   we can use this code to try any shellcode in case of linux then we compile it

            -   gcc -fno-stack-protector -z execstack ShellcodeTester.c -o ShellcodeTester

    -   **there are 2 methods to use a shellcode within attacks**

        -   the first one is inside an exploit

        -   the second one by backdooring executable files that make it do something extra while executing the file Ex we can backdoor calc.exe to execute something when starting without the knowledge of the user

            -   bad characters and shellcode size isn't a concern here

        -   in case we use the shellcode inside an exploit we must consider some points :

            -   try to make the shellcode size very small because we are restricted by the size of the buffer that will contain the exploit and this differ from one program to another

            -   the bad characters differs from one exploit to another depends on the program that contain the vulnerability

    -   **Extracting shellcode from assembly**

        -   Objdump -d ProgramA -M intel

        -   for i in \`objdump -d ProgramA \| tr \'\\t\' \' \' \| tr \' \' \'\\n\' \| egrep \'\^\[0-9a-f\]{2}\$\' \` ; do echo -n \"\\x\$i\" ; done ; echo -e \"\\n\"

    -   **Pushing strings into stack:**

        -   **Pushing string the wrong way into shellcode**

            -   **Assembly code**

                -   global \_start

                -   section .text

                -   \_start:

                -   ;Write() Syscall

                -   xor eax,eax ;clear the register before using it

                -   mov al, 0x4 ;4 = write() syscall number

                -   xor ebx,ebx ;clear the register before using it

                -   mov bl, 0x1 ;1 = stdout = print to the screen

                -   mov ecx, message ;message is a pointer to the string

                -   xor edx,edx ;clear the register before using it

                -   mov dl, 24 ;length of the string + "0xA" = 24 in decimal

                -   int 0x80 ;invoke the syscall

                -   

                -   ;Exit() Syscall

                -   mov al, 0x1 ;1 = exit() syscall number

                -   xor ebx,ebx ;setting EBX to 0 = Exit() status code

                -   int 0x80 ;invoke the syscall

                -   

                -   section .data

                -   message: db \"Speak Less, Listen More\", 0xA ;declare \"message\" , assign the string to it and append 0xA to print on new line.

            ![wrong way](images/shellcoding/push_string.png)

            -   This assembly code is good when not using it as a shellcode because when we try to extract our shellcode from the program we only extract the .text section and our shellcode wont contain our string because our string is located at the .data section so to solve this problem we have to make the shellcode contains our string we have 2 methods :

    -   **Method 1: pushing string to stack manually**

        -   1-ASCII Text:

            -   ex1: Calc.exe

            -   ex2: abcdefghijkl

        -   2-Split Text into groups of 4 characters:

            -   Ex1: \"calc\"

            -   \".exe\"

            -   Ex2 :

            -   \"abcd\"

            -   \"efgh\"

            -   "ijkl\"

        -   3-Reverse the order of the character groups:

            -   Ex1 :

                -   \".exe\"

                -   \"calc\"

            -   Ex2 :

                -   \"ijkl\"

                -   \"efgh\"

                -   \"abcd\"

        -   4-Look on google for a ASCII to hex converter and convert each character while maintaining the order:

            -   Ex1:

                -   \"\\x2E\\x65\\x78\\x65\"

                -   \"\\x63\\x61\\x6C\\x63\"

            -   EX2:

                -   \"\\x69\\x6A\\x6B\\x6C\"

                -   \"\\x65\\x66\\x67\\x68\"

                -   \"\\x61\\x62\\x63\\x64\"

        -   5-To write these values to the stack simply add \"\\x68\" in front of each group

            -   Ex1:

                -   \"\\x33\\xc0\" =\> XOR EAX,EAX

                -   \"\\x50\" =\> PUSH EAX

                -   \"\\x68\\x2E\\x65\\x78\\x65\" =\> PUSH \".exe\"

                -   \"\\x68\\x63\\x61\\x6C\\x63\" =\> PUSH \"calc\"

            -   Ex2:

                -   \"\\x33\\xc0\" =\> XOR EAX,EAX

                -   \"\\x50\" =\> PUSH EAX

                -   \"\\x68\\x69\\x6A\\x6B\\x6C\" =\> PUSH \"ijkl\"

                -   \"\\x68\\x65\\x66\\x67\\x68\" =\> PUSH \"efgh\"

                -   \"\\x68\\x61\\x62\\x63\\x64\" =\> PUSH \"abcd\"

        -   6-now the esp that points to the top of the stack also points to our string so now we will Copy string address to ECX so that ecx also points to the string

            -   mov ecx,esp

        -   Notes: need to remember:

            -   1\) the stack grows downward so we need to push the last argument first

            -   2)if the string length isn't divisible by 4 we can add a space

            -   3\) We need \"calc.exe\" + \"\\x00\"\' the \\x00 act as a string terminator but we know that null-bytes are bad characters however we can easily xor a register (which will then contain 4 null-bytes) and push it to the stack just before we push "calc.exe".)

    -   **Method 2: jmp call pop**

        -   the second method is better when writing a shellcode because it's preferred that a shellcode doesn't contain any hardcoded addresses so it can work on any os and can be portable

        -   the CPU execute the instructions in order until it meets a jmp/call instruction that pause the execution flow

            -   first the program will save the next instruction address after the call by pushing it into the stack

            -   then the program execute what's inside the function

            -   finally when it finish it execute the Return instruction that it pop back the memory address of the next instruction and execute it and complete the normal flow

        -   so how can we benefit from that to push strings into the stack dynamically without using hardcoded addresses

        -   ![call jmp pop](images/shellcoding/call_jmp_pop.png)

            -   First execute the jmp short instruction and go to the instruction "call GetAddressReturn"

            -   Then the call function will jmp back to the function GetStringAddressReturn and saving the next instruction which is our string into the stack

            -   Our string will be on top of the stack and We can then pop that address when we need like we did "pop Ecx"

-   # Windows shellcoding

    -   Linux, unlike windows, provides a direct way to interface with the kernel through the **int 0x80** interface.. Windows on the other hand, does not have a direct kernel interface. The system must be interfaced by loading the address of the function that needs to be executed from a DLL (Dynamic Link Library). The key difference between the two is the fact that the address of the functions found in windows will vary from OS version to OS version while the int 0x80 syscall numbers will remain constant. Windows programmers did this so that they could make any change needed to the kernel without any hassle; Linux on the contrary has fixed numbering system for all kernel level functions

    -   Unlike Linux, in Windows, applications can't directly accesss system calls. Instead they use functions from the Windows API (WinAPI), which internally call functions from the Native API (NtAPI), which in turn use system calls. The Native API functions are undocumented, implemented in ntdll.dll

    -   The documented functions from the Windows API are stored in kernel32.dll, advapi32.dll, gdi32.dll and others. The base services (like working with file systems, processes, devices, etc.) are provided by kernel32.dll.

    -   So, what about windows? How do I find the addresses of my needed DLL functions? Don\'t these addresses change with every service pack upgrade?

    -   There are multitudes of ways to find the addresses of the functions that you need to use in your shellcode. There are two methods for addressing functions:

        -   you can find the desired function at runtime or use hard coded addresses.

    -   The only DLL that is guaranteed to be mapped into the shellcode\'s address space is kernel32.dll. This DLL will hold LoadLibrary and GetProcAddress, the two functions needed to obtain any functions address that can be mapped into the exploits process space. There is a problem with this method though, the address offsets will change with every new release of Windows (service packs, patches etc.). So, if you use the Hardcoded addresses method your shellcode will ONLY work for a specific version of Windows.

    -   **Using hard coded addresses of Dll's functions**

    -   **Getting memory addresses of functions in dll At runtime**

        -   The OS allocates a structure for every running process, the first structure is the TEB, accessible from the FS segment register, at offset 0x30 within TEB is the pointer to the PEB fs:\[0x30\]. The PEB structure holds infos about heaps, binary image infos and most important, 3 linked lists regarding loaded modules that have been mapped in the process space. So starting from here we can find the kernel32.dll address, rising the modules addresses that are store always with fixed offsets. As said at offset 0xc within the PEB is the pointer to the PEB\_LDR\_DATA structure, which contains 3 doubly linked lists of LDR\_DATA\_TABLE structures, one for each loaded module. The DllBase field in the kernel32.dll entry is the value we're seeking. So the steps are here listed:

        -   1\. PEB is located at 0x3 from File Segment register

        -   2\. LDR (PEB structure) is located at PEB + 0xc offset

        -   3\. InMemoryOrderModuleList is the order in which the modules get stored in memory and is located at LDR + 0x14 offset

        -   4\. 1st module is the exe address itself

        -   5\. 2nd module is the ntdll.dll address

        -   6\. 3rd module is the kernel32.dll address at offset LDR + 0x10

        -   \- The 3rd module is what we are seeking but we need to know one last thing. Everytime a dll is loaded, the address gets stored at the offset of DllBase wich is 0x18. Our start address of linked list will be stored in the offset of InMemoeryOrderLinks which is at offset 0x08. Thus the offset difference would be:

        -   \- DllBase - InMemoryOrderLinks = 0x18 - 0x08 = 0x10![C:\\Users\\didi\\OneDrive\\Desktop\\windows\_api\_address.jpeg]

        -   

-   # Encoding Shellcode

    -   **Introduction**

    -   **Simple xor encoding**

        -   choose a specific byte that are not found in your shellcode and use the same byte to encode the shellcode by xoring it with every bite of the shellcode

    -   **Rolling xor encoding**

        -   We are going to take the output of the first bytes XOR as the input for the second byte, then that output as the input for the third etc etc.

        ![rolling xor](images/shellcoding/rolling_xor.jpeg)

        -   **Steps**

            -   Take the first byte of our shellcode

            -   XOR it with our seed byte (0x90)

            -   Save the first byte value as our next XOR key

            -   Overwrite the first byte in the shellcode with the result of the XOR

            -   Loop until the end of our shellcode

            -   Pass execution to the address of the start of our shellcode

        -   **Rolling Xor encoder with python**

            -   \- \#!/usr/bin/python

            -   \- shellcode = \"\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x50\\x89\\xe2\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80\"

            -   \-

            -   \- out = \[\]

            -   \- out.append(0x90)

            -   \-

            -   \- for i in range(0, len(shellcode)):

            -   \- b1 = ord(shellcode\[i\]) \^ out\[i\]

            -   \- out.append(b1)

            -   \-

            -   \- print(\"\\nOut Length: \")

            -   \- print(str(len(out)-1))

            -   \- print(\", \".join(hex(c) for c in out\[1::\]))

        -   **Assembly code rolling decoder**

            -   global \_start

            -   section .text

            -   \_start:

            -   jmp short call\_decoder

            -   decoder:

            -   pop esi ; Store our Shellcode start address

            -   mov cl, 25 ; Set our counter (shellcode is 25 bytes long)

            -   xor eax, eax ; Zero eax

            -   cdq ; Zero edx

            -   mov al, 0x90 ; Move 0x90 (XOR Seed) into eax

            -   decode:

            -   mov dl, \[esi\] ; Move byte at esi into edx

            -   xor al, dl ; XOR eax and edx

            -   mov \[esi\], al ; Overwrite the encoded shellcode with the decoded result

            -   mov al, dl ; Move the original byte into eax to use as the key next

            -   inc esi ; Increment esi

            -   loop decode ; Loop until ecx is 0 (25 times)

            -   

            -   jmp short Shellcode ; Pass execution to the decoded shellcode

            -   

            -   call\_decoder:

            -   call decoder

            -   Shellcode: db 0xa1, 0x61, 0x31, 0x59, 0x76, 0x59, 0x2a, 0x42, 0x2a, 0x5, 0x67, 0xe, 0x60, 0xe9, 0xa, 0x5a, 0xd3, 0x31, 0x62, 0xeb, 0xa, 0xba, 0xb1, 0x7c, 0xfc
